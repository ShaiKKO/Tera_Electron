{"version":3,"file":"game.bundle.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACkD;AACa;AACG;AAClE;AACO;AACP;AACO,mCAAmC,0DAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0EAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0EAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0EAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0EAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0EAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0EAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA,6CAA6C,wBAAwB,sBAAsB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAiB;AACjB;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;;AC3GD;AACA;AACA;AACA;AACA;AACkD;AACa;AAC/D;AACO;AACP;AACO,gCAAgC,0DAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,wBAAwB,sBAAsB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAiB;AACjB;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;;AC/CD;AACA;AACA;AACA;AACA;AACkD;AACa;AAC/D;AACO;AACP;AACO,gCAAgC,0DAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,wBAAwB,0BAA0B;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAiB;AACjB;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;;;;;;AC/CD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACoD;AACA;AACF;AACO;AACzD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2DAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2DAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2DAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2DAAY;AAC5B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAY;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAY;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAY;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAY;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,6DAAa;AACrB;AACA,QAAQ,6DAAa;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6DAAa;AAC7B;AACA;AACA;AACA;AACA;AACA,uEAAuE,6BAA6B;AACpG;AACA;AACA;AACA;AACA,YAAY,6DAAa;AACzB;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA,QAAQ,2DAAY;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,6DAAa;AAC/C,kCAAkC,6DAAa;AAC/C;AACA;AACA;AACA,gCAAgC,2BAA2B;AAC3D,0BAA0B,iCAAiC;AAC3D,2BAA2B,kCAAkC;AAC7D,2BAA2B,kCAAkC;AAC7D,6BAA6B,wBAAwB;AACrD,0BAA0B,iCAAiC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6DAAa;AAC5B;AACA;AACA;AACA;AACA;AACA,eAAe,6DAAa;AAC5B;AACA;AACA;AACA;AACA;AACA,eAAe,2DAAY;AAC3B;AACA;AACA;AACA;AACA;AACA,eAAe,kEAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,+CAA+C;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,kBAAkB;AACzE;AACA;AACA;AACA,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA,QAAQ,2DAAY;AACpB;AACA;AACA;AACA;AACO;;;;;;;;;;;;;;;;AC/fP;AACA;AACA;AACA;AACA;AACA;AACqC;AACrC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,2BAA2B,6CAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kBAAkB;AAClD;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC7FA;AACA;AACA;AACA;AACA;AACA;AAC+C;AAC/C;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wDAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wDAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,+DAA+D,wDAAoB;AAC1F;AACA,aAAa,wDAAoB;AACjC;AACA,aAAa,wDAAoB;AACjC;AACA;AACA,+DAA+D,YAAY;AAC3E;AACA;;;;;;;;;;;;;;;;;;AC9SA;AACA;AACA;AACA;AACA;AACA;AACqC;AACK;AACI;AAC9C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,6CAAI;AAC7B,uCAAuC,oBAAoB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uDAAY,MAAM,mDAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uDAAY,MAAM,mDAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gBAAgB,EAAE,mBAAO,CAAC,6DAAiB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uDAAY,MAAM,mDAAe;AAC7C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,SAAS,SAAS,WAAW,UAAU,0BAA0B;AAC7F;AACA;;;;;;;;;;;;;;;;;;;;;ACtKA;AACA;AACA;AACA;AACA;AACA;AACkC;AAC0B;AACd;AACkB;AACN;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wDAAoB;AACtD;AACA;AACA;AACA;AACA,QAAQ,uDAAY,WAAW,mDAAe;AAC9C,QAAQ,uDAAY,WAAW,mDAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,2BAA2B,2CAAM;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uDAAY,MAAM,mDAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uDAAY,MAAM,mDAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yEAAsB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uDAAY,MAAM,mDAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uDAAY,MAAM,mDAAe;AACzC;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,8CAA8C,kEAAiB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;;;;;;;;;;;;;;;;;AC7aP;AACA;AACA;AACA;AACA;AACA;AACqC;AACrC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,6CAAI;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,UAAU;AACxE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;;;;;;;;;;;;;;;;;;;ACrJP;AACA;AACA;AACA;AACA;AACA;AACqC;AACW;AACF;AACY;AAC1D;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6CAAI;AACvB;AACA,iFAAiF,kDAAc;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uDAAY,MAAM,mDAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,yDAAa;AACtC;AACA;AACA;AACA,QAAQ,uDAAY,MAAM,mDAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uDAAY,MAAM,mDAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,UAAU;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,SAAS;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;;;;;;;;;;;;;;;;;;AC3PP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C;AACO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD;AACrD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACO;AACP;AACA;AACA;AACA;AACA,CAAC,0CAA0C;;;;;;;;;;;;;;;;ACtC3C;AACA;AACA;AACA;AACA;AAC6D;AAC7D;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,cAAc,GAAG,cAAc;AAC7D;AACA;AACA;AACA;AACA;AACA,sCAAsC,WAAW,GAAG,WAAW;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,mBAAmB;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qEAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qEAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oCAAoC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,qEAAgB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA,sCAAsC,iBAAiB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qEAAgB;AAClC;AACA,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,qEAAgB;AACzD,2BAA2B,0BAA0B;AACrD;AACA;AACA;AACA;;;;;;;;;;;;;;;ACrPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,YAAY;AAC1B,cAAc,aAAa;AAC3B,cAAc,aAAa;AAC3B,cAAc,aAAa;AAC3B,cAAc,aAAa;AAC3B,cAAc;AACd;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B,cAAc,YAAY;AAC1B,cAAc,YAAY;AAC1B,cAAc,aAAa;AAC3B,cAAc,aAAa;AAC3B,cAAc,cAAc;AAC5B;AACA;AACA,2BAA2B,UAAU;AACrC;AACA,4BAA4B,YAAY;AACxC,+BAA+B,MAAM;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,uBAAuB;AAC9D;AACA;AACA;AACA,+BAA+B,WAAW;AAC1C,+BAA+B,MAAM;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC1OA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AACtD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,UAAU,IAAI,6BAA6B;AACtE;AACA,6CAA6C,sDAAsD;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,YAAY;AAC1B,cAAc,YAAY;AAC1B,cAAc,YAAY;AAC1B,cAAc,aAAa;AAC3B,cAAc,aAAa;AAC3B,cAAc,aAAa;AAC3B,cAAc;AACd;AACA;AACA;AACA,0BAA0B,+DAAgB;AAC1C;AACA,4BAA4B,+DAAgB;AAC5C;AACA;AACA,qEAAqE,oBAAoB;AACzF,0CAA0C,sBAAsB;AAChE,6CAA6C,wBAAwB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,YAAY;AAC1B,cAAc,YAAY;AAC1B,cAAc,YAAY;AAC1B,cAAc,aAAa;AAC3B,cAAc,aAAa;AAC3B,cAAc,cAAc;AAC5B,cAAc;AACd;AACA;AACA;AACA,0BAA0B,+DAAgB;AAC1C;AACA,6BAA6B,+DAAgB;AAC7C;AACA;AACA,uEAAuE,qBAAqB;AAC5F,0CAA0C,sBAAsB;AAChE,8CAA8C,yBAAyB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,YAAY;AAC1B,cAAc,YAAY;AAC1B,cAAc,YAAY;AAC1B,cAAc,aAAa;AAC3B,cAAc,aAAa;AAC3B,cAAc,aAAa;AAC3B,cAAc;AACd;AACA;AACA;AACA,yBAAyB,+DAAgB;AACzC;AACA,0BAA0B,+DAAgB;AAC1C;AACA,4BAA4B,+DAAgB;AAC5C;AACA;AACA,6BAA6B,+DAAgB;AAC7C;AACA,yEAAyE,oBAAoB;AAC7F,yCAAyC,qBAAqB;AAC9D,6CAA6C,wBAAwB;AACrE,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,0BAA0B,+DAAgB;AAC1C;AACA;AACA,6BAA6B,+DAAgB;AAC7C;AACA,6DAA6D,yBAAyB;AACtF,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA,wDAAwD,kBAAkB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,YAAY;AAC1B,cAAc,aAAa;AAC3B,cAAc,aAAa;AAC3B,cAAc;AACd;AACA;AACA,wBAAwB,kBAAkB;AAC1C,gCAAgC,kBAAkB;AAClD;AACA;AACA,2BAA2B,+DAAgB;AAC3C,2BAA2B,+DAAgB;AAC3C;AACA,+DAA+D,kBAAkB,IAAI,kBAAkB,MAAM,GAAG,UAAU,kBAAkB,IAAI,kBAAkB,MAAM,GAAG;AAC3K;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C,4BAA4B,kBAAkB;AAC9C;AACA;AACA,gCAAgC,kBAAkB;AAClD;AACA;AACA;AACA;AACA;AACA,gCAAgC,+DAAgB;AAChD,gCAAgC,+DAAgB;AAChD,gCAAgC,+DAAgB;AAChD;AACA,yEAAyE,kBAAkB,IAAI,kBAAkB,MAAM,KAAK,IAAI,KAAK,IAAI,KAAK,MAAM,kBAAkB,IAAI,kBAAkB,QAAQ,kBAAkB,IAAI,kBAAkB;AAC5O;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,6BAA6B,aAAa;AAC1C,yBAAyB,+DAAgB;AACzC;AACA;AACA,iCAAiC,+DAAgB;AACjD;AACA,oEAAoE,oBAAoB;AACxF,0DAA0D,OAAO,YAAY,SAAS;AACtF;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,aAAa,YAAY,WAAW;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,6BAA6B,aAAa;AAC1C,0BAA0B,+DAAgB;AAC1C;AACA;AACA,iCAAiC,+DAAgB;AACjD;AACA,yDAAyD,oBAAoB;AAC7E,iEAAiE,OAAO,YAAY,SAAS;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,cAAc,YAAY,cAAc;AAC3G;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC1PA;AACA;AACA;AACA;AACA;AACA;AAC8B;AAC9B;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA,+CAA+C,UAAU,mCAAmC,8BAA8B;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uCAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;;;;;;;;;;;;;;;ACpKP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB,GAAG,OAAO,GAAG,0BAA0B;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO,GAAG,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,WAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS,GAAG,gBAAgB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,SAAS,GAAG,gBAAgB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,EAAE;AAC7C;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACmD;AACO;AACA;AACP;AACQ;AACA;AACA;AAC3D;AACA;AACA;AACA;AACA;AACA,2BAA2B,mEAAc;AACzC;AACA;AACA;AACA;AACA,sBAAsB,2DAAc;AACpC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,QAAQ,4CAAI,wBAAwB,qDAAa;AACjD,QAAQ,4CAAI,wBAAwB,qDAAa;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAI;AAChB,YAAY,4CAAI;AAChB,YAAY,4CAAI,2BAA2B;AAC3C,YAAY,4CAAI,kBAAkB;AAClC,kBAAkB,4CAAI;AACtB;AACA;AACA,YAAY,kEAAa;AACzB;AACA;AACA;AACA,YAAY,4CAAI,wBAAwB,qDAAa;AACrD,YAAY,4CAAI,wBAAwB,qDAAa;AACrD,YAAY,4CAAI,wBAAwB,qDAAa;AACrD;AACA,YAAY,4CAAI;AAChB,yDAAyD,kEAAa;AACtE,mBAAmB,4CAAI;AACvB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,6CAA6C,qBAAqB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yCAAyC;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kEAAa;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kEAAa,gBAAgB,gBAAgB;AACpE;AACA;AACA,QAAQ,kEAAa,6BAA6B,mEAAiB;AACnE,QAAQ,kEAAa,6BAA6B,mEAAiB;AACnE;AACA,wBAAwB,QAAQ;AAChC,2BAA2B,kEAAa,gBAAgB,gBAAgB,MAAM,GAAG;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kEAAa,6BAA6B,mEAAiB;AACvE,YAAY,kEAAa,6BAA6B,mEAAiB;AACvE;AACA;AACA;AACA;AACO;;;;;;;;;;;;;;;;;;;ACpNP;AACA;AACA;AACA;AACA;AAC4C;AACmB;AACA;AACZ;AACnD;AACA;AACA;AACO,6BAA6B,oDAAM;AAC1C;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,8BAA8B,4BAA4B,2DAAc;AACxE,iCAAiC,uEAAqB,EAAE,uEAAqB;AAC7E,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,uEAAqB;AACtE,iDAAiD,uEAAqB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC;AACA;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC;AACA;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC;AACA;;;;;;;UCnEA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACoD;AACF;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAI;AAChB;AACA,YAAY,4CAAI;AAChB;AACA,YAAY,4CAAI;AAChB;AACA,YAAY,4CAAI;AAChB;AACA,YAAY,4CAAI;AAChB;AACA;AACA,KAAK;AACL;AACA;AACA,YAAY,4CAAI;AAChB;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAI,wBAAwB,qDAAa;AACrD,YAAY,4CAAI,wBAAwB,qDAAa;AACrD;AACA,kBAAkB,6DAAW;AAC7B;AACA,0CAA0C,4CAAI;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,iBAAiB,WAAW;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiE;AACwB;AACzB;AACG;AACnE;AAGuF;AACvF;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,0EAAgB;AAChE,4DAA4D,kGAA4B;AACxF,oDAAoD,yEAAoB;AACxE,8CAA8C,4EAAc;AAC5D;AACA","sources":["webpack://TerraFluxGame/webpack/universalModuleDefinition","webpack://TerraFluxGame/./src/game/components/HexPosition.ts","webpack://TerraFluxGame/./src/game/components/Position.ts","webpack://TerraFluxGame/./src/game/components/Velocity.ts","webpack://TerraFluxGame/./src/game/core/Game.ts","webpack://TerraFluxGame/./src/game/core/ecs/Component.ts","webpack://TerraFluxGame/./src/game/core/ecs/ComponentStorage.ts","webpack://TerraFluxGame/./src/game/core/ecs/Entity.ts","webpack://TerraFluxGame/./src/game/core/ecs/EntityManager.ts","webpack://TerraFluxGame/./src/game/core/ecs/EventEmitter.ts","webpack://TerraFluxGame/./src/game/core/ecs/System.ts","webpack://TerraFluxGame/./src/game/core/ecs/SystemManager.ts","webpack://TerraFluxGame/./src/game/core/ecs/types.ts","webpack://TerraFluxGame/./src/game/core/pathfinding/HexPathfinding.ts","webpack://TerraFluxGame/./src/game/core/utils/CoordinateSystem.ts","webpack://TerraFluxGame/./src/game/core/utils/CoordinateSystemVerification.ts","webpack://TerraFluxGame/./src/game/core/utils/TypeRegistry.ts","webpack://TerraFluxGame/./src/game/core/utils/UUID.ts","webpack://TerraFluxGame/./src/game/example/GameExample.ts","webpack://TerraFluxGame/./src/game/systems/MovementSystem.ts","webpack://TerraFluxGame/webpack/bootstrap","webpack://TerraFluxGame/webpack/runtime/define property getters","webpack://TerraFluxGame/webpack/runtime/hasOwnProperty shorthand","webpack://TerraFluxGame/webpack/runtime/make namespace object","webpack://TerraFluxGame/./src/game/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"TerraFluxGame\"] = factory();\n\telse\n\t\troot[\"TerraFluxGame\"] = factory();\n})(this, () => {\nreturn ","/**\n * TerraFlux - Hex Position Component\n *\n * Represents a position in the hex grid coordinate system.\n */\nimport { Component } from '../core/ecs/Component';\nimport { componentRegistry } from '../core/utils/TypeRegistry';\nimport { CoordinateSystem } from '../core/utils/CoordinateSystem';\n// Component ID\nexport const HEX_POSITION_COMPONENT_ID = 'hexPosition';\n// Hex Position component\nexport class HexPositionComponent extends Component {\n    constructor(q = 0, r = 0) {\n        super();\n        // Type ID of this component\n        this.typeId = HEX_POSITION_COMPONENT_ID;\n        // Hex grid coordinates (axial system)\n        this.q = 0;\n        this.r = 0;\n        this.q = q;\n        this.r = r;\n    }\n    /**\n     * Clone the component\n     */\n    clone() {\n        return new HexPositionComponent(this.q, this.r);\n    }\n    /**\n     * Reset component to its initial state\n     */\n    reset() {\n        this.q = 0;\n        this.r = 0;\n    }\n    /**\n     * Get the world position corresponding to this hex position\n     */\n    toWorld() {\n        return CoordinateSystem.hexToWorld(this.q, this.r);\n    }\n    /**\n     * Set the position from world coordinates\n     *\n     * @param x World X coordinate\n     * @param y World Y coordinate\n     */\n    fromWorld(x, y) {\n        const hex = CoordinateSystem.worldToHex(x, y);\n        this.q = hex.q;\n        this.r = hex.r;\n    }\n    /**\n     * Get the grid position corresponding to this hex position\n     */\n    toGrid() {\n        return CoordinateSystem.hexToGrid(this.q, this.r);\n    }\n    /**\n     * Set the position from grid coordinates\n     *\n     * @param x Grid X coordinate\n     * @param y Grid Y coordinate\n     */\n    fromGrid(x, y) {\n        const hex = CoordinateSystem.gridToHex(x, y);\n        this.q = hex.q;\n        this.r = hex.r;\n    }\n    /**\n     * Calculate the distance to another hex position\n     *\n     * @param other The other hex position\n     * @returns Distance in hex units\n     */\n    distanceTo(other) {\n        return CoordinateSystem.hexDistance(this.q, this.r, other.q, other.r);\n    }\n    /**\n     * Get the neighboring hex positions\n     *\n     * @returns Array of neighboring hex positions\n     */\n    getNeighbors() {\n        return CoordinateSystem.getHexNeighbors(this.q, this.r);\n    }\n    /**\n     * Serialize component data\n     */\n    serialize() {\n        return Object.assign(Object.assign({}, super.serialize()), { q: this.q, r: this.r });\n    }\n    /**\n     * Deserialize component data\n     */\n    deserialize(data) {\n        var _a, _b;\n        super.deserialize(data);\n        this.q = (_a = data.q) !== null && _a !== void 0 ? _a : 0;\n        this.r = (_b = data.r) !== null && _b !== void 0 ? _b : 0;\n    }\n}\n// Register the hex position component\ncomponentRegistry.register({\n    id: HEX_POSITION_COMPONENT_ID,\n    name: 'HexPosition',\n    create: () => new HexPositionComponent()\n});\n","/**\n * TerraFlux - Position Component\n *\n * Represents a position in 2D space.\n */\nimport { Component } from '../core/ecs/Component';\nimport { componentRegistry } from '../core/utils/TypeRegistry';\n// Component ID\nexport const POSITION_COMPONENT_ID = 'position';\n// Position component\nexport class PositionComponent extends Component {\n    constructor(x = 0, y = 0) {\n        super();\n        // Type ID of this component\n        this.typeId = POSITION_COMPONENT_ID;\n        // Position data\n        this.x = 0;\n        this.y = 0;\n        this.x = x;\n        this.y = y;\n    }\n    // Clone the component\n    clone() {\n        return new PositionComponent(this.x, this.y);\n    }\n    // Reset component to its initial state\n    reset() {\n        this.x = 0;\n        this.y = 0;\n    }\n    // Serialize component data\n    serialize() {\n        return Object.assign(Object.assign({}, super.serialize()), { x: this.x, y: this.y });\n    }\n    // Deserialize component data\n    deserialize(data) {\n        var _a, _b;\n        super.deserialize(data);\n        this.x = (_a = data.x) !== null && _a !== void 0 ? _a : 0;\n        this.y = (_b = data.y) !== null && _b !== void 0 ? _b : 0;\n    }\n}\n// Register the position component\ncomponentRegistry.register({\n    id: POSITION_COMPONENT_ID,\n    name: 'Position',\n    create: () => new PositionComponent()\n});\n","/**\n * TerraFlux - Velocity Component\n *\n * Represents velocity in 2D space.\n */\nimport { Component } from '../core/ecs/Component';\nimport { componentRegistry } from '../core/utils/TypeRegistry';\n// Component ID\nexport const VELOCITY_COMPONENT_ID = 'velocity';\n// Velocity component\nexport class VelocityComponent extends Component {\n    constructor(vx = 0, vy = 0) {\n        super();\n        // Type ID of this component\n        this.typeId = VELOCITY_COMPONENT_ID;\n        // Velocity data\n        this.vx = 0;\n        this.vy = 0;\n        this.vx = vx;\n        this.vy = vy;\n    }\n    // Clone the component\n    clone() {\n        return new VelocityComponent(this.vx, this.vy);\n    }\n    // Reset component to its initial state\n    reset() {\n        this.vx = 0;\n        this.vy = 0;\n    }\n    // Serialize component data\n    serialize() {\n        return Object.assign(Object.assign({}, super.serialize()), { vx: this.vx, vy: this.vy });\n    }\n    // Deserialize component data\n    deserialize(data) {\n        var _a, _b;\n        super.deserialize(data);\n        this.vx = (_a = data.vx) !== null && _a !== void 0 ? _a : 0;\n        this.vy = (_b = data.vy) !== null && _b !== void 0 ? _b : 0;\n    }\n}\n// Register the velocity component\ncomponentRegistry.register({\n    id: VELOCITY_COMPONENT_ID,\n    name: 'Velocity',\n    create: () => new VelocityComponent()\n});\n","/**\n * TerraFlux - Game Core\n *\n * Central game engine class that ties together the ECS framework.\n * Manages the game loop, timing, and provides access to global managers.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { entityManager } from './ecs/EntityManager';\nimport { systemManager } from './ecs/SystemManager';\nimport { eventEmitter } from './ecs/EventEmitter';\nimport { componentRegistry } from './utils/TypeRegistry';\n/**\n * Game state enumeration\n */\nexport var GameState;\n(function (GameState) {\n    GameState[\"UNINITIALIZED\"] = \"uninitialized\";\n    GameState[\"INITIALIZING\"] = \"initializing\";\n    GameState[\"READY\"] = \"ready\";\n    GameState[\"RUNNING\"] = \"running\";\n    GameState[\"PAUSED\"] = \"paused\";\n    GameState[\"STOPPING\"] = \"stopping\";\n    GameState[\"STOPPED\"] = \"stopped\";\n})(GameState || (GameState = {}));\n/**\n * Game event types\n */\nexport var GameEventType;\n(function (GameEventType) {\n    GameEventType[\"INITIALIZED\"] = \"game_initialized\";\n    GameEventType[\"STARTED\"] = \"game_started\";\n    GameEventType[\"PAUSED\"] = \"game_paused\";\n    GameEventType[\"RESUMED\"] = \"game_resumed\";\n    GameEventType[\"STOPPED\"] = \"game_stopped\";\n    GameEventType[\"UPDATE\"] = \"game_update\";\n    GameEventType[\"ERROR\"] = \"game_error\";\n    GameEventType[\"TIME_SCALE_CHANGED\"] = \"game_time_scale_changed\";\n    GameEventType[\"TIMESTEP_MODE_CHANGED\"] = \"game_timestep_mode_changed\";\n    GameEventType[\"PERFORMANCE_SNAPSHOT\"] = \"game_performance_snapshot\";\n})(GameEventType || (GameEventType = {}));\n/**\n * Central game engine class\n */\nexport class Game {\n    /**\n     * Constructor for Game\n     *\n     * @param config Game configuration options\n     */\n    constructor(config = {}) {\n        var _a, _b, _c, _d, _e, _f;\n        /**\n         * Current game state\n         */\n        this._state = GameState.UNINITIALIZED;\n        /**\n         * Time of the last frame\n         */\n        this._lastFrameTime = 0;\n        /**\n         * Time accumulator for fixed timestep\n         */\n        this._accumulator = 0;\n        /**\n         * Stats about the game loop\n         */\n        this._stats = {\n            fps: 0,\n            frameTime: 0,\n            updateTime: 0,\n            renderTime: 0,\n            idleTime: 0,\n            totalFrames: 0,\n            droppedFrames: 0,\n            timeScale: 1.0,\n            entityCount: 0,\n            systemCount: 0\n        };\n        this._targetFPS = (_a = config.targetFPS) !== null && _a !== void 0 ? _a : 60;\n        this._maxDeltaTime = (_b = config.maxDeltaTime) !== null && _b !== void 0 ? _b : 0.25; // 250ms\n        this._debug = (_c = config.debug) !== null && _c !== void 0 ? _c : false;\n        this._useFixedTimestep = (_d = config.useFixedTimestep) !== null && _d !== void 0 ? _d : false;\n        this._fixedTimestepValue = (_e = config.fixedTimestepValue) !== null && _e !== void 0 ? _e : 1 / 60;\n        this._timeScale = (_f = config.timeScale) !== null && _f !== void 0 ? _f : 1.0;\n        // Auto-start if specified\n        if (config.autoStart) {\n            this.initialize().then(() => this.start());\n        }\n    }\n    /**\n     * Get the current game state\n     */\n    get state() {\n        return this._state;\n    }\n    /**\n     * Get the target updates per second\n     */\n    get targetFPS() {\n        return this._targetFPS;\n    }\n    /**\n     * Set the target updates per second\n     */\n    set targetFPS(value) {\n        this._targetFPS = value;\n    }\n    /**\n     * Get whether fixed timestep is being used\n     */\n    get useFixedTimestep() {\n        return this._useFixedTimestep;\n    }\n    /**\n     * Set whether fixed timestep should be used\n     */\n    set useFixedTimestep(value) {\n        const oldValue = this._useFixedTimestep;\n        this._useFixedTimestep = value;\n        if (oldValue !== this._useFixedTimestep) {\n            eventEmitter.emit(GameEventType.TIMESTEP_MODE_CHANGED, this, this._useFixedTimestep);\n        }\n    }\n    /**\n     * Get the fixed timestep value in seconds\n     */\n    get fixedTimestepValue() {\n        return this._fixedTimestepValue;\n    }\n    /**\n     * Set the fixed timestep value in seconds\n     */\n    set fixedTimestepValue(value) {\n        this._fixedTimestepValue = Math.max(0.001, Math.min(0.1, value));\n    }\n    /**\n     * Get the time scale factor\n     */\n    get timeScale() {\n        return this._timeScale;\n    }\n    /**\n     * Set the time scale factor\n     */\n    set timeScale(value) {\n        const oldValue = this._timeScale;\n        this._timeScale = Math.max(0.1, Math.min(10, value));\n        if (oldValue !== this._timeScale) {\n            eventEmitter.emit(GameEventType.TIME_SCALE_CHANGED, this, this._timeScale);\n        }\n    }\n    /**\n     * Get the maximum delta time\n     */\n    get maxDeltaTime() {\n        return this._maxDeltaTime;\n    }\n    /**\n     * Set the maximum delta time\n     */\n    set maxDeltaTime(value) {\n        this._maxDeltaTime = value;\n    }\n    /**\n     * Get whether the game is currently in debug mode\n     */\n    get debug() {\n        return this._debug;\n    }\n    /**\n     * Set whether the game is currently in debug mode\n     */\n    set debug(value) {\n        this._debug = value;\n    }\n    /**\n     * Get the current game stats\n     */\n    get stats() {\n        return this._stats;\n    }\n    /**\n     * Initialize the game\n     *\n     * @returns Promise that resolves when initialization is complete\n     */\n    initialize() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Check if we're already initialized\n            if (this._state !== GameState.UNINITIALIZED) {\n                return true;\n            }\n            // Set state to initializing\n            this._state = GameState.INITIALIZING;\n            try {\n                // Initialize core systems\n                // If needed, this is where we would load configuration, \n                // assets, or set up any other required infrastructure\n                // Set state to ready\n                this._state = GameState.READY;\n                // Emit initialized event\n                eventEmitter.emit(GameEventType.INITIALIZED, this);\n                return true;\n            }\n            catch (error) {\n                // Set state back to uninitialized\n                this._state = GameState.UNINITIALIZED;\n                // Emit error event\n                eventEmitter.emit(GameEventType.ERROR, this, error);\n                // Re-throw the error\n                throw error;\n            }\n        });\n    }\n    /**\n     * Start the game loop\n     *\n     * @returns True if the game was started successfully\n     */\n    start() {\n        // Check if we're in a valid state to start\n        if (this._state !== GameState.READY && this._state !== GameState.PAUSED && this._state !== GameState.STOPPED) {\n            return false;\n        }\n        // Set state to running\n        this._state = GameState.RUNNING;\n        // Reset frame time\n        this._lastFrameTime = performance.now();\n        // Start the game loop\n        this._rafId = requestAnimationFrame(this._gameLoop.bind(this));\n        // Emit started event\n        eventEmitter.emit(GameEventType.STARTED, this);\n        return true;\n    }\n    /**\n     * Pause the game loop\n     *\n     * @returns True if the game was paused successfully\n     */\n    pause() {\n        // Check if we're in a valid state to pause\n        if (this._state !== GameState.RUNNING) {\n            return false;\n        }\n        // Set state to paused\n        this._state = GameState.PAUSED;\n        // Stop the game loop\n        if (this._rafId !== undefined) {\n            cancelAnimationFrame(this._rafId);\n            this._rafId = undefined;\n        }\n        // Emit paused event\n        eventEmitter.emit(GameEventType.PAUSED, this);\n        return true;\n    }\n    /**\n     * Resume the game loop\n     *\n     * @returns True if the game was resumed successfully\n     */\n    resume() {\n        // Check if we're in a valid state to resume\n        if (this._state !== GameState.PAUSED) {\n            return false;\n        }\n        // Set state to running\n        this._state = GameState.RUNNING;\n        // Reset frame time\n        this._lastFrameTime = performance.now();\n        // Start the game loop\n        this._rafId = requestAnimationFrame(this._gameLoop.bind(this));\n        // Emit resumed event\n        eventEmitter.emit(GameEventType.RESUMED, this);\n        return true;\n    }\n    /**\n     * Stop the game loop\n     *\n     * @returns True if the game was stopped successfully\n     */\n    stop() {\n        // Check if we're in a valid state to stop\n        if (this._state !== GameState.RUNNING && this._state !== GameState.PAUSED) {\n            return false;\n        }\n        // Set state to stopping\n        this._state = GameState.STOPPING;\n        // Stop the game loop\n        if (this._rafId !== undefined) {\n            cancelAnimationFrame(this._rafId);\n            this._rafId = undefined;\n        }\n        // Reset stats\n        this._stats = {\n            fps: 0,\n            frameTime: 0,\n            updateTime: 0,\n            renderTime: 0,\n            idleTime: 0,\n            totalFrames: 0,\n            droppedFrames: 0,\n            timeScale: this._timeScale,\n            entityCount: 0,\n            systemCount: 0\n        };\n        // Set state to stopped\n        this._state = GameState.STOPPED;\n        // Emit stopped event\n        eventEmitter.emit(GameEventType.STOPPED, this);\n        return true;\n    }\n    /**\n     * Reset the game to its initial state\n     *\n     * @returns True if the game was reset successfully\n     */\n    reset() {\n        // Stop the game first\n        this.stop();\n        // Clear all entities\n        entityManager.clear();\n        // Clear all systems\n        systemManager.clear();\n        // Set state to ready\n        this._state = GameState.READY;\n        return true;\n    }\n    /**\n     * Main game loop\n     *\n     * @param timestamp Current timestamp from requestAnimationFrame\n     */\n    _gameLoop(timestamp) {\n        // Calculate delta time with time scaling\n        const rawDeltaTime = Math.min((timestamp - this._lastFrameTime) / 1000, this._maxDeltaTime);\n        const scaledDeltaTime = rawDeltaTime * this._timeScale;\n        this._lastFrameTime = timestamp;\n        // Start update timing\n        const updateStartTime = performance.now();\n        if (this._useFixedTimestep) {\n            // Fixed timestep implementation\n            this._accumulator += scaledDeltaTime;\n            // Run as many fixed updates as needed\n            let updatesThisFrame = 0;\n            while (this._accumulator >= this._fixedTimestepValue && updatesThisFrame < 10) {\n                // Update systems with fixed timestep\n                systemManager.update(this._fixedTimestepValue);\n                this._accumulator -= this._fixedTimestepValue;\n                updatesThisFrame++;\n            }\n            // If we've hit max updates but still have accumulator time, we're falling behind\n            if (this._accumulator >= this._fixedTimestepValue && this._debug) {\n                console.warn(`Game loop falling behind! Accumulator: ${this._accumulator.toFixed(3)}s`);\n            }\n        }\n        else {\n            // Standard variable timestep\n            systemManager.update(scaledDeltaTime);\n        }\n        // End update timing\n        const updateEndTime = performance.now();\n        // Start render timing (placeholder for future rendering system)\n        const renderStartTime = performance.now();\n        const renderEndTime = renderStartTime; // No rendering yet\n        // Update stats\n        this._updateStats(rawDeltaTime, updateEndTime - updateStartTime, renderEndTime - renderStartTime);\n        // Emit update event\n        eventEmitter.emit(GameEventType.UPDATE, this, scaledDeltaTime);\n        // Continue the loop if still running\n        if (this._state === GameState.RUNNING) {\n            this._rafId = requestAnimationFrame(this._gameLoop.bind(this));\n        }\n    }\n    /**\n     * Update game stats\n     *\n     * @param deltaTime Time elapsed since the last update in seconds\n     * @param updateTime Time taken for the update in milliseconds\n     * @param renderTime Time taken for rendering in milliseconds\n     */\n    _updateStats(deltaTime, updateTime, renderTime = 0) {\n        // Calculate frame time and determine if frame was dropped\n        const frameTime = updateTime + renderTime;\n        const targetFrameTime = 1000 / this._targetFPS;\n        const droppedFrame = frameTime > targetFrameTime * 1.2; // 20% margin\n        // Calculate idle time (time spent not updating or rendering)\n        const idleTime = Math.max(0, targetFrameTime - frameTime);\n        // Increment total frames\n        this._stats.totalFrames++;\n        if (droppedFrame)\n            this._stats.droppedFrames++;\n        // Calculate exponential moving averages\n        const alpha = 0.1; // Smoothing factor\n        this._stats.fps = (1 / deltaTime) * alpha + this._stats.fps * (1 - alpha);\n        this._stats.frameTime = frameTime * alpha + this._stats.frameTime * (1 - alpha);\n        this._stats.updateTime = updateTime * alpha + this._stats.updateTime * (1 - alpha);\n        this._stats.renderTime = renderTime * alpha + this._stats.renderTime * (1 - alpha);\n        this._stats.idleTime = idleTime * alpha + this._stats.idleTime * (1 - alpha);\n        // Update entity and system counts\n        this._stats.entityCount = entityManager.getEntityCount();\n        this._stats.systemCount = systemManager.getSystemCount();\n        this._stats.timeScale = this._timeScale;\n        // Log stats in debug mode\n        if (this._debug && this._stats.totalFrames % 60 === 0) {\n            console.log(`FPS: ${this._stats.fps.toFixed(2)}, ` +\n                `Frame: ${this._stats.frameTime.toFixed(2)}ms, ` +\n                `Update: ${this._stats.updateTime.toFixed(2)}ms, ` +\n                `Render: ${this._stats.renderTime.toFixed(2)}ms, ` +\n                `Entities: ${this._stats.entityCount}, ` +\n                `Speed: ${this._stats.timeScale.toFixed(1)}x`);\n        }\n    }\n    /**\n     * Get the entity manager\n     */\n    get entityManager() {\n        return entityManager;\n    }\n    /**\n     * Get the system manager\n     */\n    get systemManager() {\n        return systemManager;\n    }\n    /**\n     * Get the event emitter\n     */\n    get eventEmitter() {\n        return eventEmitter;\n    }\n    /**\n     * Get the component registry\n     */\n    get componentRegistry() {\n        return componentRegistry;\n    }\n    /**\n     * Toggle between fixed and variable timestep\n     * @returns New timestep mode (true = fixed, false = variable)\n     */\n    toggleTimestepMode() {\n        this.useFixedTimestep = !this._useFixedTimestep;\n        if (this._debug) {\n            console.log(`Switched to ${this._useFixedTimestep ? 'fixed' : 'variable'} timestep mode`);\n        }\n        return this._useFixedTimestep;\n    }\n    /**\n     * Cycle through game speeds (normal -> fast -> ultra-fast -> normal)\n     * @returns New time scale value\n     */\n    cycleGameSpeed() {\n        if (this._timeScale <= 1.0) {\n            this.setFastSpeed();\n        }\n        else if (this._timeScale <= 2.0) {\n            this.setUltraFastSpeed();\n        }\n        else {\n            this.setNormalSpeed();\n        }\n        if (this._debug) {\n            console.log(`Game speed set to ${this._timeScale}x`);\n        }\n        return this._timeScale;\n    }\n    /**\n     * Set normal game speed (1x)\n     */\n    setNormalSpeed() {\n        this.timeScale = 1.0;\n    }\n    /**\n     * Set fast game speed (2x)\n     */\n    setFastSpeed() {\n        this.timeScale = 2.0;\n    }\n    /**\n     * Set ultra-fast game speed (5x)\n     */\n    setUltraFastSpeed() {\n        this.timeScale = 5.0;\n    }\n    /**\n     * Take a performance snapshot\n     * @returns Object with detailed performance metrics\n     */\n    takePerformanceSnapshot() {\n        const snapshot = Object.assign(Object.assign({}, this._stats), { timestamp: Date.now(), memory: typeof performance !== 'undefined' && 'memory' in performance ? {\n                jsHeapSizeLimit: performance.memory.jsHeapSizeLimit,\n                totalJSHeapSize: performance.memory.totalJSHeapSize,\n                usedJSHeapSize: performance.memory.usedJSHeapSize\n            } : undefined });\n        if (this._debug) {\n            console.table(snapshot);\n        }\n        // Emit performance snapshot event\n        eventEmitter.emit(GameEventType.PERFORMANCE_SNAPSHOT, this, snapshot);\n        return snapshot;\n    }\n}\n// Create a global game instance\nexport const game = new Game();\n","/**\n * TerraFlux - Component Base Class\n *\n * Provides the foundation for all components in the ECS architecture.\n * Components are pure data containers with minimal logic.\n */\nimport { UUID } from '../utils/UUID';\n/**\n * Abstract base class for all components\n */\nexport class Component {\n    /**\n     * Constructor for Component\n     */\n    constructor() {\n        this._instanceId = UUID.generateWithPrefix('comp-inst');\n    }\n    /**\n     * Get the unique instance ID for this component\n     */\n    get instanceId() {\n        return this._instanceId;\n    }\n    /**\n     * Clone this component to create a new instance with the same data\n     * Derived classes should override this to properly copy their data\n     */\n    clone() {\n        // This is a basic implementation that should be overridden\n        // by derived classes to properly copy their data\n        const clone = Object.create(Object.getPrototypeOf(this));\n        return Object.assign(clone, this);\n    }\n    /**\n     * Reset the component to its initial state for reuse from pool\n     * Derived classes should override this to properly reset their data\n     */\n    reset() {\n        // This is a basic implementation that should be overridden\n        // by derived classes to properly reset their data\n    }\n    /**\n     * Serialize the component to a JSON-compatible object\n     * Derived classes should override this to properly serialize their data\n     *\n     * @returns A JSON-compatible object representing this component's data\n     */\n    serialize() {\n        // Default implementation - derived classes should override\n        return {\n            typeId: this.typeId,\n            instanceId: this.instanceId\n        };\n    }\n    /**\n     * Deserialize the component from a JSON-compatible object\n     * Derived classes should override this to properly deserialize their data\n     *\n     * @param data A JSON-compatible object to deserialize from\n     */\n    deserialize(data) {\n        // Default implementation - derived classes should override\n        // Most implementations will do nothing with typeId and instanceId\n        // as these are typically immutable, but may be used for validation\n    }\n    /**\n     * Creates an object pool factory for this component type\n     * This can be used to efficiently reuse component instances\n     *\n     * @param ComponentClass The component class to create a pool for\n     * @param initialSize The initial size of the pool\n     * @param growthFactor How much to grow the pool by when more instances are needed\n     * @returns A factory function that creates/reuses component instances\n     */\n    static createPool(ComponentClass, initialSize = 10, growthFactor = 5) {\n        // Create the initial pool of components\n        const pool = Array(initialSize)\n            .fill(null)\n            .map(() => new ComponentClass());\n        // Return a factory function that gets from the pool or creates new instances\n        return () => {\n            // If there are no components left in the pool, add more\n            if (pool.length === 0) {\n                for (let i = 0; i < growthFactor; i++) {\n                    pool.push(new ComponentClass());\n                }\n            }\n            // Return a component from the pool\n            const component = pool.pop();\n            component.reset(); // Ensure the component is reset to initial state\n            return component;\n        };\n    }\n}\n","/**\n * TerraFlux - Component Storage\n *\n * Provides storage implementations for components in the ECS architecture.\n * Implements both Array of Structs (AoS) and Struct of Arrays (SoA) approaches.\n */\nimport { ComponentStorageType } from './types';\n/**\n * Array of Structs (AoS) implementation of component storage\n * Each entity's components are stored together in a map\n * Good for complex relational components or those accessed together\n */\nexport class ArrayComponentStorage {\n    /**\n     * Constructor\n     *\n     * @param componentTypeId The component type ID\n     */\n    constructor(componentTypeId) {\n        /**\n         * The type of storage strategy\n         */\n        this.storageType = ComponentStorageType.ARRAY_OF_STRUCTS;\n        /**\n         * Maps entity IDs to components\n         */\n        this.entityComponentMap = new Map();\n        this.componentTypeId = componentTypeId;\n    }\n    /**\n     * Add a component for an entity\n     *\n     * @param entityId The entity ID\n     * @param component The component to add\n     * @returns True if the component was added, false if it already existed\n     */\n    add(entityId, component) {\n        // Check if this entity already has this component\n        if (this.entityComponentMap.has(entityId)) {\n            return false;\n        }\n        // Add the component\n        this.entityComponentMap.set(entityId, component);\n        return true;\n    }\n    /**\n     * Get a component for an entity\n     *\n     * @param entityId The entity ID\n     * @returns The component, or undefined if not found\n     */\n    get(entityId) {\n        return this.entityComponentMap.get(entityId);\n    }\n    /**\n     * Check if an entity has a component\n     *\n     * @param entityId The entity ID\n     * @returns True if the entity has the component\n     */\n    has(entityId) {\n        return this.entityComponentMap.has(entityId);\n    }\n    /**\n     * Remove a component from an entity\n     *\n     * @param entityId The entity ID\n     * @returns The removed component, or undefined if not found\n     */\n    remove(entityId) {\n        const component = this.entityComponentMap.get(entityId);\n        if (component) {\n            this.entityComponentMap.delete(entityId);\n        }\n        return component;\n    }\n    /**\n     * Get all entities that have a component\n     *\n     * @returns Array of entity IDs\n     */\n    getEntities() {\n        return Array.from(this.entityComponentMap.keys());\n    }\n    /**\n     * Get all components\n     *\n     * @returns Array of components\n     */\n    getComponents() {\n        return Array.from(this.entityComponentMap.values());\n    }\n    /**\n     * Get entity and component pairs\n     *\n     * @returns Array of entity ID and component pairs\n     */\n    getEntityComponentPairs() {\n        return Array.from(this.entityComponentMap.entries());\n    }\n    /**\n     * Clear all components\n     */\n    clear() {\n        this.entityComponentMap.clear();\n    }\n    /**\n     * Get the number of components in the storage\n     *\n     * @returns The number of components\n     */\n    count() {\n        return this.entityComponentMap.size;\n    }\n    /**\n     * Get the component type ID\n     *\n     * @returns The component type ID\n     */\n    getComponentTypeId() {\n        return this.componentTypeId;\n    }\n}\n/**\n * Struct of Arrays (SoA) implementation of component storage\n * Each component type has its own array, optimized for system iteration\n * Better for cache coherency and performance-critical components\n */\nexport class SparseSetComponentStorage {\n    /**\n     * Constructor\n     *\n     * @param componentTypeId The component type ID\n     */\n    constructor(componentTypeId) {\n        /**\n         * The type of storage strategy\n         */\n        this.storageType = ComponentStorageType.STRUCT_OF_ARRAYS;\n        /**\n         * Maps entity IDs to indices in the dense array\n         */\n        this.sparse = new Map();\n        /**\n         * Dense array of entity IDs\n         */\n        this.denseEntities = [];\n        /**\n         * Dense array of components, parallel to denseEntities\n         */\n        this.denseComponents = [];\n        this.componentTypeId = componentTypeId;\n    }\n    /**\n     * Add a component for an entity\n     *\n     * @param entityId The entity ID\n     * @param component The component to add\n     * @returns True if the component was added, false if it already existed\n     */\n    add(entityId, component) {\n        // Check if this entity already has this component\n        if (this.sparse.has(entityId)) {\n            return false;\n        }\n        // Add to dense arrays\n        const index = this.denseEntities.length;\n        this.denseEntities.push(entityId);\n        this.denseComponents.push(component);\n        // Map entity ID to index\n        this.sparse.set(entityId, index);\n        return true;\n    }\n    /**\n     * Get a component for an entity\n     *\n     * @param entityId The entity ID\n     * @returns The component, or undefined if not found\n     */\n    get(entityId) {\n        const index = this.sparse.get(entityId);\n        if (index === undefined) {\n            return undefined;\n        }\n        return this.denseComponents[index];\n    }\n    /**\n     * Check if an entity has a component\n     *\n     * @param entityId The entity ID\n     * @returns True if the entity has the component\n     */\n    has(entityId) {\n        return this.sparse.has(entityId);\n    }\n    /**\n     * Remove a component from an entity\n     *\n     * @param entityId The entity ID\n     * @returns The removed component, or undefined if not found\n     */\n    remove(entityId) {\n        const index = this.sparse.get(entityId);\n        if (index === undefined) {\n            return undefined;\n        }\n        // Get the component that will be removed\n        const component = this.denseComponents[index];\n        // If this is not the last element, move the last element to this position\n        const lastIndex = this.denseEntities.length - 1;\n        if (index !== lastIndex) {\n            // Move the last entity/component to this position\n            const lastEntityId = this.denseEntities[lastIndex];\n            this.denseEntities[index] = lastEntityId;\n            this.denseComponents[index] = this.denseComponents[lastIndex];\n            // Update the sparse map for the moved entity\n            this.sparse.set(lastEntityId, index);\n        }\n        // Remove the last entity/component (now duplicated or the one we want to remove)\n        this.denseEntities.pop();\n        this.denseComponents.pop();\n        // Remove from sparse map\n        this.sparse.delete(entityId);\n        return component;\n    }\n    /**\n     * Get all entities that have a component\n     *\n     * @returns Array of entity IDs\n     */\n    getEntities() {\n        return [...this.denseEntities];\n    }\n    /**\n     * Get all components\n     *\n     * @returns Array of components\n     */\n    getComponents() {\n        return [...this.denseComponents];\n    }\n    /**\n     * Get entity and component pairs\n     *\n     * @returns Array of entity ID and component pairs\n     */\n    getEntityComponentPairs() {\n        return this.denseEntities.map((entityId, index) => [entityId, this.denseComponents[index]]);\n    }\n    /**\n     * Clear all components\n     */\n    clear() {\n        this.sparse.clear();\n        this.denseEntities = [];\n        this.denseComponents = [];\n    }\n    /**\n     * Get the number of components in the storage\n     *\n     * @returns The number of components\n     */\n    count() {\n        return this.denseEntities.length;\n    }\n    /**\n     * Get the component type ID\n     *\n     * @returns The component type ID\n     */\n    getComponentTypeId() {\n        return this.componentTypeId;\n    }\n    /**\n     * Get direct access to the dense arrays for optimized iteration\n     * WARNING: Do not modify these arrays directly unless you know what you're doing\n     *\n     * @returns Object containing dense entity and component arrays\n     */\n    getDenseArrays() {\n        return {\n            entities: this.denseEntities,\n            components: this.denseComponents\n        };\n    }\n}\n/**\n * Factory function to create a component storage based on the specified strategy\n *\n * @param componentTypeId The component type ID\n * @param storageType The storage strategy to use\n * @returns A component storage instance\n */\nexport function createComponentStorage(componentTypeId, storageType = ComponentStorageType.STRUCT_OF_ARRAYS) {\n    switch (storageType) {\n        case ComponentStorageType.ARRAY_OF_STRUCTS:\n            return new ArrayComponentStorage(componentTypeId);\n        case ComponentStorageType.STRUCT_OF_ARRAYS:\n            return new SparseSetComponentStorage(componentTypeId);\n        default:\n            throw new Error(`Unknown component storage type: ${storageType}`);\n    }\n}\n","/**\n * TerraFlux - Entity\n *\n * The core entity class for the ECS architecture.\n * Entities are essentially just IDs with collections of components and tags.\n */\nimport { UUID } from '../utils/UUID';\nimport { EntityEventType } from './types';\nimport { eventEmitter } from './EventEmitter';\n/**\n * Entity class representing a game object in the ECS architecture\n */\nexport class Entity {\n    /**\n     * Create a new entity\n     *\n     * @param id Optional unique identifier. If not provided, a new one will be generated.\n     * @param name Optional human-readable name for debugging\n     */\n    constructor(id, name) {\n        /**\n         * Tags associated with this entity for filtering\n         */\n        this._tags = new Set();\n        this._id = id || UUID.generateEntityId();\n        this._name = name || `Entity_${this._id.substr(-6)}`;\n    }\n    /**\n     * Get the entity's unique identifier\n     */\n    get id() {\n        return this._id;\n    }\n    /**\n     * Get the entity's name\n     */\n    get name() {\n        return this._name;\n    }\n    /**\n     * Set the entity's name\n     */\n    set name(value) {\n        this._name = value;\n    }\n    /**\n     * Add a tag to the entity\n     *\n     * @param tag The tag to add\n     * @returns This entity for method chaining\n     */\n    addTag(tag) {\n        if (!this._tags.has(tag)) {\n            this._tags.add(tag);\n            eventEmitter.emit(EntityEventType.TAG_ADDED, this, tag);\n        }\n        return this;\n    }\n    /**\n     * Remove a tag from the entity\n     *\n     * @param tag The tag to remove\n     * @returns True if the tag was removed, false if it wasn't present\n     */\n    removeTag(tag) {\n        if (this._tags.has(tag)) {\n            this._tags.delete(tag);\n            eventEmitter.emit(EntityEventType.TAG_REMOVED, this, tag);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Check if the entity has a specific tag\n     *\n     * @param tag The tag to check for\n     * @returns True if the entity has the tag\n     */\n    hasTag(tag) {\n        return this._tags.has(tag);\n    }\n    /**\n     * Get all tags for this entity\n     *\n     * @returns Array of tags for this entity\n     */\n    getTags() {\n        return [...this._tags];\n    }\n    /**\n     * Get a component from this entity\n     *\n     * @param componentId The component type ID to get\n     * @returns The component, or undefined if not found\n     */\n    getComponent(componentId) {\n        // Components are stored in the EntityManager, so we need to use it here\n        // This is a convenience method that delegates to the EntityManager\n        // Dynamically import to avoid circular dependencies\n        const { entityManager } = require('./EntityManager');\n        return entityManager.getComponent(this.id, componentId);\n    }\n    /**\n     * Clear all tags from the entity\n     *\n     * @returns This entity for method chaining\n     */\n    clearTags() {\n        const tags = this.getTags();\n        this._tags.clear();\n        tags.forEach(tag => {\n            eventEmitter.emit(EntityEventType.TAG_REMOVED, this, tag);\n        });\n        return this;\n    }\n    /**\n     * Serialize this entity to a JSON-compatible object\n     * Note: Component attachment/detachment is handled by EntityManager\n     *\n     * @returns A JSON-compatible object\n     */\n    serialize() {\n        return {\n            id: this._id,\n            name: this._name,\n            tags: this.getTags()\n        };\n    }\n    /**\n     * Deserialize this entity from a JSON-compatible object\n     * Note: Component attachment/detachment is handled by EntityManager\n     *\n     * @param data A JSON-compatible object\n     */\n    deserialize(data) {\n        // ID is immutable, so we don't set it\n        // Set name\n        if (data.name) {\n            this._name = data.name;\n        }\n        // Clear and re-add tags\n        this.clearTags();\n        if (Array.isArray(data.tags)) {\n            data.tags.forEach((tag) => {\n                this.addTag(tag);\n            });\n        }\n    }\n    /**\n     * Check if this entity equals another entity\n     * Entities are equal if they have the same ID\n     *\n     * @param other The other entity to compare with\n     * @returns True if the entities are equal\n     */\n    equals(other) {\n        return this._id === other._id;\n    }\n    /**\n     * Convert the entity to a string\n     *\n     * @returns A string representation of the entity\n     */\n    toString() {\n        return `Entity(id=${this._id}, name=${this._name}, tags=[${this.getTags().join(', ')}])`;\n    }\n}\n","/**\n * TerraFlux - Entity Manager\n *\n * Manages entity lifecycle, component attachment, and entity querying.\n * Provides efficient way to query entities based on components and tags.\n */\nimport { Entity } from './Entity';\nimport { createComponentStorage } from './ComponentStorage';\nimport { eventEmitter } from './EventEmitter';\nimport { EntityEventType, ComponentStorageType } from './types';\nimport { componentRegistry } from '../utils/TypeRegistry';\n/**\n * Creates an ArchetypeKey from a list of component IDs\n */\nfunction createArchetypeKey(componentIds) {\n    return [...componentIds].sort().join('|');\n}\n/**\n * EntityManager class responsible for managing entity lifecycle\n * and component attachment/detachment\n */\nexport class EntityManager {\n    /**\n     * Create a new EntityManager\n     */\n    constructor(defaultStorageType) {\n        /**\n         * Map of entity IDs to entities\n         */\n        this.entities = new Map();\n        /**\n         * Map of component type IDs to their storage\n         */\n        this.componentStorages = new Map();\n        /**\n         * Map of entity archetypes to sets of entity IDs\n         * Used for efficient querying of entities with specific component combinations\n         */\n        this.entityArchetypes = new Map();\n        /**\n         * Map of tags to sets of entity IDs\n         * Used for efficient querying of entities with specific tags\n         */\n        this.entityTags = new Map();\n        /**\n         * Default component storage type for new component types\n         */\n        this.defaultStorageType = ComponentStorageType.STRUCT_OF_ARRAYS;\n        if (defaultStorageType !== undefined) {\n            this.defaultStorageType = defaultStorageType;\n        }\n        // Subscribe to entity tag events to update the entity tags mapping\n        eventEmitter.subscribe(EntityEventType.TAG_ADDED, this.handleTagAdded.bind(this));\n        eventEmitter.subscribe(EntityEventType.TAG_REMOVED, this.handleTagRemoved.bind(this));\n    }\n    /**\n     * Handler for tag added event\n     */\n    handleTagAdded(entity, tag) {\n        // Ensure the tag set exists\n        if (!this.entityTags.has(tag)) {\n            this.entityTags.set(tag, new Set());\n        }\n        // Add the entity to the tag set\n        this.entityTags.get(tag).add(entity.id);\n    }\n    /**\n     * Handler for tag removed event\n     */\n    handleTagRemoved(entity, tag) {\n        // Remove the entity from the tag set\n        const tagSet = this.entityTags.get(tag);\n        if (tagSet) {\n            tagSet.delete(entity.id);\n            // Clean up empty tag sets\n            if (tagSet.size === 0) {\n                this.entityTags.delete(tag);\n            }\n        }\n    }\n    /**\n     * Create a new entity\n     */\n    createEntity(options = {}) {\n        // Create the entity\n        const entity = new Entity(options.id, options.name);\n        // Register the entity\n        this.entities.set(entity.id, entity);\n        // Add initial tags if provided\n        if (options.tags) {\n            options.tags.forEach(tag => entity.addTag(tag));\n        }\n        // Emit entity created event\n        eventEmitter.emit(EntityEventType.CREATED, entity);\n        return entity;\n    }\n    /**\n     * Get an entity by ID\n     */\n    getEntity(entityId) {\n        return this.entities.get(entityId);\n    }\n    /**\n     * Check if an entity exists\n     */\n    hasEntity(entityId) {\n        return this.entities.has(entityId);\n    }\n    /**\n     * Destroy an entity and remove all its components\n     */\n    destroyEntity(entityId) {\n        const entity = this.entities.get(entityId);\n        if (!entity) {\n            return false;\n        }\n        // Remove all components\n        for (const componentStorage of this.componentStorages.values()) {\n            if (componentStorage.has(entityId)) {\n                // This will update archetypes internally\n                this.removeComponent(entityId, componentStorage.getComponentTypeId());\n            }\n        }\n        // Clear entity tags\n        entity.clearTags();\n        // Remove from entities map\n        this.entities.delete(entityId);\n        // Emit entity destroyed event\n        eventEmitter.emit(EntityEventType.DESTROYED, entity);\n        return true;\n    }\n    /**\n     * Get all entities\n     */\n    getAllEntities() {\n        return Array.from(this.entities.values());\n    }\n    /**\n     * Get the number of entities\n     */\n    getEntityCount() {\n        return this.entities.size;\n    }\n    /**\n     * Get or create a component storage\n     */\n    getOrCreateComponentStorage(componentTypeId, storageType) {\n        // Check if storage already exists\n        let storage = this.componentStorages.get(componentTypeId);\n        if (!storage) {\n            // Create new storage\n            storage = createComponentStorage(componentTypeId, storageType || this.defaultStorageType);\n            this.componentStorages.set(componentTypeId, storage);\n        }\n        return storage;\n    }\n    /**\n     * Update entity archetypes when components are added or removed\n     */\n    updateEntityArchetypes(entityId, oldComponentTypes, newComponentTypes) {\n        // Remove from old archetype\n        const oldArchetypeKey = createArchetypeKey(oldComponentTypes);\n        const oldArchetype = this.entityArchetypes.get(oldArchetypeKey);\n        if (oldArchetype) {\n            oldArchetype.delete(entityId);\n            // Clean up empty archetypes\n            if (oldArchetype.size === 0) {\n                this.entityArchetypes.delete(oldArchetypeKey);\n            }\n        }\n        // Add to new archetype\n        const newArchetypeKey = createArchetypeKey(newComponentTypes);\n        if (!this.entityArchetypes.has(newArchetypeKey)) {\n            this.entityArchetypes.set(newArchetypeKey, new Set());\n        }\n        this.entityArchetypes.get(newArchetypeKey).add(entityId);\n    }\n    /**\n     * Get all component types for an entity\n     */\n    getEntityComponentTypes(entityId) {\n        const componentTypes = [];\n        for (const [componentTypeId, storage] of this.componentStorages.entries()) {\n            if (storage.has(entityId)) {\n                componentTypes.push(componentTypeId);\n            }\n        }\n        return componentTypes;\n    }\n    /**\n     * Add a component to an entity\n     */\n    addComponent(entityId, component) {\n        // Check if entity exists\n        if (!this.hasEntity(entityId)) {\n            return false;\n        }\n        // Get the component storage\n        const componentTypeId = component.typeId;\n        const storage = this.getOrCreateComponentStorage(componentTypeId);\n        // Check if already has this component\n        if (storage.has(entityId)) {\n            return false;\n        }\n        // Get current component types before adding\n        const oldComponentTypes = this.getEntityComponentTypes(entityId);\n        // Add component to storage\n        storage.add(entityId, component);\n        // Update archetypes\n        const newComponentTypes = [...oldComponentTypes, componentTypeId];\n        this.updateEntityArchetypes(entityId, oldComponentTypes, newComponentTypes);\n        // Emit component added event\n        const entity = this.entities.get(entityId);\n        eventEmitter.emit(EntityEventType.COMPONENT_ADDED, entity, component);\n        return true;\n    }\n    /**\n     * Get a component from an entity\n     */\n    getComponent(entityId, componentTypeId) {\n        // Check if entity exists\n        if (!this.hasEntity(entityId)) {\n            return undefined;\n        }\n        // Get the component storage\n        const storage = this.componentStorages.get(componentTypeId);\n        if (!storage) {\n            return undefined;\n        }\n        // Get the component\n        return storage.get(entityId);\n    }\n    /**\n     * Check if an entity has a component\n     */\n    hasComponent(entityId, componentTypeId) {\n        // Check if entity exists\n        if (!this.hasEntity(entityId)) {\n            return false;\n        }\n        // Get the component storage\n        const storage = this.componentStorages.get(componentTypeId);\n        if (!storage) {\n            return false;\n        }\n        // Check if the entity has the component\n        return storage.has(entityId);\n    }\n    /**\n     * Remove a component from an entity\n     */\n    removeComponent(entityId, componentTypeId) {\n        // Check if entity exists\n        if (!this.hasEntity(entityId)) {\n            return undefined;\n        }\n        // Get the component storage\n        const storage = this.componentStorages.get(componentTypeId);\n        if (!storage) {\n            return undefined;\n        }\n        // Check if has component\n        if (!storage.has(entityId)) {\n            return undefined;\n        }\n        // Get current component types before removal\n        const oldComponentTypes = this.getEntityComponentTypes(entityId);\n        // Remove the component\n        const component = storage.remove(entityId);\n        // Update archetypes\n        const newComponentTypes = oldComponentTypes.filter(id => id !== componentTypeId);\n        this.updateEntityArchetypes(entityId, oldComponentTypes, newComponentTypes);\n        // Emit component removed event\n        const entity = this.entities.get(entityId);\n        eventEmitter.emit(EntityEventType.COMPONENT_REMOVED, entity, component);\n        return component;\n    }\n    /**\n     * Query entities based on components, tags, and filters\n     */\n    queryEntities(options = {}) {\n        // Start with all entities\n        let result = new Set(this.entities.keys());\n        // Filter by required components\n        if (options.withComponents && options.withComponents.length > 0) {\n            for (const componentId of options.withComponents) {\n                const storage = this.componentStorages.get(componentId);\n                if (!storage || storage.count() === 0) {\n                    // No entities have this component\n                    return [];\n                }\n                const entitiesWithComponent = storage.getEntities();\n                result = new Set([...result].filter(id => entitiesWithComponent.includes(id)));\n                if (result.size === 0) {\n                    // No entities left after filtering\n                    return [];\n                }\n            }\n        }\n        // Filter by excluded components\n        if (options.withoutComponents && options.withoutComponents.length > 0) {\n            for (const componentId of options.withoutComponents) {\n                const storage = this.componentStorages.get(componentId);\n                if (storage) {\n                    const entitiesWithComponent = storage.getEntities();\n                    entitiesWithComponent.forEach(id => result.delete(id));\n                }\n            }\n        }\n        // Filter by required tags\n        if (options.withTags && options.withTags.length > 0) {\n            for (const tag of options.withTags) {\n                const entitiesWithTag = this.entityTags.get(tag);\n                if (!entitiesWithTag || entitiesWithTag.size === 0) {\n                    // No entities have this tag\n                    return [];\n                }\n                result = new Set([...result].filter(id => entitiesWithTag.has(id)));\n                if (result.size === 0) {\n                    // No entities left after filtering\n                    return [];\n                }\n            }\n        }\n        // Filter by excluded tags\n        if (options.withoutTags && options.withoutTags.length > 0) {\n            for (const tag of options.withoutTags) {\n                const entitiesWithTag = this.entityTags.get(tag);\n                if (entitiesWithTag) {\n                    entitiesWithTag.forEach(id => result.delete(id));\n                }\n            }\n        }\n        // Apply custom filter if provided\n        if (options.filter) {\n            const entities = [...result].map(id => this.entities.get(id));\n            const filteredEntities = entities.filter(entity => options.filter(entity));\n            return filteredEntities;\n        }\n        // Convert result set to array of entities\n        return [...result].map(id => this.entities.get(id));\n    }\n    /**\n     * Get all entities with a specific component\n     */\n    getEntitiesWithComponent(componentTypeId) {\n        const storage = this.componentStorages.get(componentTypeId);\n        if (!storage) {\n            return [];\n        }\n        return storage.getEntities().map(id => this.entities.get(id));\n    }\n    /**\n     * Get all entities with a specific tag\n     */\n    getEntitiesWithTag(tag) {\n        const entityIds = this.entityTags.get(tag);\n        if (!entityIds) {\n            return [];\n        }\n        return [...entityIds].map(id => this.entities.get(id));\n    }\n    /**\n     * Clear all entities and components\n     */\n    clear() {\n        // Clear all entities\n        for (const entityId of this.entities.keys()) {\n            this.destroyEntity(entityId);\n        }\n        // Clear all component storages\n        this.componentStorages.clear();\n        // Clear all entity archetypes\n        this.entityArchetypes.clear();\n        // Clear all entity tags\n        this.entityTags.clear();\n    }\n    /**\n     * Serialize all entities\n     */\n    serialize() {\n        const entities = [];\n        for (const entity of this.entities.values()) {\n            const serializedEntity = entity.serialize();\n            // Add components\n            const components = {};\n            for (const [componentTypeId, storage] of this.componentStorages.entries()) {\n                const component = storage.get(entity.id);\n                if (component) {\n                    components[componentTypeId] = component.serialize();\n                }\n            }\n            serializedEntity.components = components;\n            entities.push(serializedEntity);\n        }\n        return { entities };\n    }\n    /**\n     * Deserialize entities\n     */\n    deserialize(data) {\n        // Clear existing entities\n        this.clear();\n        // Deserialize entities\n        if (Array.isArray(data.entities)) {\n            for (const entityData of data.entities) {\n                // Create entity\n                const entity = this.createEntity({\n                    id: entityData.id,\n                    name: entityData.name,\n                    tags: entityData.tags\n                });\n                // Add components\n                if (entityData.components) {\n                    for (const [componentTypeId, componentData] of Object.entries(entityData.components)) {\n                        // Create component\n                        const componentType = componentRegistry.getById(componentTypeId);\n                        if (componentType) {\n                            const component = componentType.create();\n                            component.deserialize(componentData);\n                            this.addComponent(entity.id, component);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n// Create a global entity manager instance\nexport const entityManager = new EntityManager();\n","/**\n * TerraFlux - Event Emitter\n *\n * A lightweight, typed event emitter for the ECS architecture.\n * Handles entity lifecycle events, component events, and system events.\n */\nimport { UUID } from '../utils/UUID';\n/**\n * EventEmitter class for subscribing to and emitting events\n */\nexport class EventEmitter {\n    constructor() {\n        /**\n         * Maps event names to a map of subscription tokens and their callbacks\n         */\n        this.eventMap = new Map();\n    }\n    /**\n     * Subscribe to an event\n     *\n     * @param eventName The name of the event to subscribe to\n     * @param callback The function to call when the event is emitted\n     * @returns A subscription token that can be used to unsubscribe\n     */\n    subscribe(eventName, callback) {\n        // Create event map if it doesn't exist\n        if (!this.eventMap.has(eventName)) {\n            this.eventMap.set(eventName, new Map());\n        }\n        // Generate a unique subscription token\n        const subscriptionToken = UUID.generateWithPrefix('sub');\n        // Add the callback to the event map\n        const eventCallbacks = this.eventMap.get(eventName);\n        eventCallbacks.set(subscriptionToken, callback);\n        return subscriptionToken;\n    }\n    /**\n     * Unsubscribe from an event\n     *\n     * @param eventName The name of the event to unsubscribe from\n     * @param token The subscription token returned from subscribe\n     * @returns True if the subscription was successfully removed\n     */\n    unsubscribe(eventName, token) {\n        // Check if event exists\n        const eventCallbacks = this.eventMap.get(eventName);\n        if (!eventCallbacks) {\n            return false;\n        }\n        // Remove the subscription\n        return eventCallbacks.delete(token);\n    }\n    /**\n     * Emit an event to all subscribers\n     *\n     * @param eventName The name of the event to emit\n     * @param args Arguments to pass to the callback functions\n     */\n    emit(eventName, ...args) {\n        // Check if event exists\n        const eventCallbacks = this.eventMap.get(eventName);\n        if (!eventCallbacks || eventCallbacks.size === 0) {\n            return;\n        }\n        // Call all callbacks\n        eventCallbacks.forEach(callback => {\n            try {\n                callback(...args);\n            }\n            catch (error) {\n                console.error(`Error in event callback for '${eventName}':`, error);\n            }\n        });\n    }\n    /**\n     * Check if an event has subscribers\n     *\n     * @param eventName The name of the event to check\n     * @returns True if the event has subscribers\n     */\n    hasSubscribers(eventName) {\n        const eventCallbacks = this.eventMap.get(eventName);\n        return !!eventCallbacks && eventCallbacks.size > 0;\n    }\n    /**\n     * Get the number of subscribers for an event\n     *\n     * @param eventName The name of the event to check\n     * @returns The number of subscribers for the event\n     */\n    subscriberCount(eventName) {\n        const eventCallbacks = this.eventMap.get(eventName);\n        return eventCallbacks ? eventCallbacks.size : 0;\n    }\n    /**\n     * Remove all subscriptions for an event\n     *\n     * @param eventName The name of the event to clear\n     */\n    clearEvent(eventName) {\n        const eventCallbacks = this.eventMap.get(eventName);\n        if (eventCallbacks) {\n            eventCallbacks.clear();\n        }\n    }\n    /**\n     * Remove all subscriptions for all events\n     */\n    clearAllEvents() {\n        this.eventMap.forEach(eventCallbacks => {\n            eventCallbacks.clear();\n        });\n        this.eventMap.clear();\n    }\n    /**\n     * Get a list of all active event names\n     *\n     * @returns Array of event names with subscribers\n     */\n    getActiveEvents() {\n        return Array.from(this.eventMap.keys()).filter(eventName => this.subscriberCount(eventName) > 0);\n    }\n    /**\n     * Create a subscription that automatically unsubscribes when the provided\n     * lifespan object is destroyed. Useful for creating subscriptions tied to\n     * the lifecycle of a system or component.\n     *\n     * @param eventName The name of the event to subscribe to\n     * @param callback The function to call when the event is emitted\n     * @param lifespan An object with a method to register destruction callbacks\n     * @returns A subscription token that can be used to unsubscribe\n     */\n    subscribeWithLifespan(eventName, callback, lifespan) {\n        const token = this.subscribe(eventName, callback);\n        // When the lifespan object is destroyed, unsubscribe\n        // Support both System's addDestroyCallback and other objects' onDestroy\n        const registerCallback = lifespan.addDestroyCallback || lifespan.onDestroy;\n        if (registerCallback) {\n            registerCallback.call(lifespan, () => {\n                this.unsubscribe(eventName, token);\n            });\n        }\n        else {\n            console.warn('Lifespan object does not have addDestroyCallback or onDestroy method');\n        }\n        return token;\n    }\n}\n// Create a global event emitter instance\nexport const eventEmitter = new EventEmitter();\n","/**\n * TerraFlux - System Base Class\n *\n * Provides the foundation for all systems in the ECS architecture.\n * Systems operate on entities with specific component combinations.\n */\nimport { UUID } from '../utils/UUID';\nimport { entityManager } from './EntityManager';\nimport { eventEmitter } from './EventEmitter';\nimport { SystemPriority, SystemEventType } from './types';\n/**\n * Abstract base class for all systems\n */\nexport class System {\n    /**\n     * Constructor for System\n     *\n     * @param config System configuration options\n     */\n    constructor(config) {\n        var _a, _b, _c;\n        this._id = UUID.generateSystemId(config.name);\n        this._name = config.name;\n        this._priority = (_a = config.priority) !== null && _a !== void 0 ? _a : SystemPriority.NORMAL;\n        this._query = (_b = config.query) !== null && _b !== void 0 ? _b : {};\n        this._enabled = (_c = config.enabled) !== null && _c !== void 0 ? _c : true;\n    }\n    /**\n     * Get the unique identifier for this system\n     */\n    get id() {\n        return this._id;\n    }\n    /**\n     * Get the human-readable name for this system\n     */\n    get name() {\n        return this._name;\n    }\n    /**\n     * Get the priority level for this system\n     */\n    get priority() {\n        return this._priority;\n    }\n    /**\n     * Set the priority level for this system\n     */\n    set priority(value) {\n        this._priority = value;\n    }\n    /**\n     * Get whether this system is currently enabled\n     */\n    get enabled() {\n        return this._enabled;\n    }\n    /**\n     * Set whether this system is currently enabled\n     */\n    set enabled(value) {\n        if (this._enabled !== value) {\n            this._enabled = value;\n            if (value) {\n                this.onEnable();\n            }\n            else {\n                this.onDisable();\n            }\n        }\n    }\n    /**\n     * Get the query options for selecting entities\n     */\n    get query() {\n        return this._query;\n    }\n    /**\n     * Set the query options for selecting entities\n     */\n    set query(value) {\n        this._query = value;\n    }\n    /**\n     * Initialize this system\n     *\n     * @returns True if the system was successfully initialized\n     */\n    initialize() {\n        const result = this.onInitialize();\n        // Notify that the system has been initialized\n        eventEmitter.emit(SystemEventType.INITIALIZED, this);\n        return result;\n    }\n    /**\n     * Called when the system is initialized\n     * Override this to perform custom initialization\n     *\n     * @returns True if the system was successfully initialized\n     */\n    onInitialize() {\n        return true;\n    }\n    /**\n     * Called when the system is enabled\n     * Override this to perform custom enable logic\n     */\n    onEnable() {\n        // Default implementation does nothing\n    }\n    /**\n     * Called when the system is disabled\n     * Override this to perform custom disable logic\n     */\n    onDisable() {\n        // Default implementation does nothing\n    }\n    /**\n     * Update this system\n     *\n     * @param deltaTime Time elapsed since the last update in seconds\n     */\n    update(deltaTime) {\n        if (!this._enabled) {\n            return;\n        }\n        // Query entities that match this system's requirements\n        const entities = entityManager.queryEntities(this._query);\n        // Process entities\n        this.onUpdate(deltaTime, entities);\n        // Notify that the system has been updated\n        eventEmitter.emit(SystemEventType.UPDATED, this, deltaTime);\n    }\n    /**\n     * Destroy this system\n     */\n    destroy() {\n        this.onDestroy();\n        // Notify that the system has been destroyed\n        eventEmitter.emit(SystemEventType.DESTROYED, this);\n    }\n    /**\n     * Called when the system is destroyed\n     * Override this to perform custom cleanup\n     */\n    onDestroy() {\n        // Default implementation does nothing\n    }\n    /**\n     * Register a callback to be executed when the system is destroyed\n     * Used by other systems like the EventEmitter for cleanup\n     *\n     * @param callback Function to call when the system is destroyed\n     */\n    addDestroyCallback(callback) {\n        const originalOnDestroy = this.onDestroy.bind(this);\n        this.onDestroy = () => {\n            originalOnDestroy();\n            callback();\n        };\n    }\n}\n","/**\n * TerraFlux - System Manager\n *\n * Manages the lifecycle and execution of all systems.\n * Handles system registration, dependencies, and priority-based execution.\n */\n/**\n * SystemManager class responsible for managing system lifecycle\n * and priority-based execution\n */\nexport class SystemManager {\n    constructor() {\n        /**\n         * Map of system IDs to systems\n         */\n        this.systems = new Map();\n        /**\n         * System dependencies - which systems must run before others\n         */\n        this.dependencies = [];\n        /**\n         * Flag to track if systems are sorted\n         */\n        this.sorted = true;\n        /**\n         * Ordered list of systems based on priority and dependencies\n         */\n        this.orderedSystems = [];\n    }\n    /**\n     * Add a system to the manager\n     *\n     * @param system The system to add\n     * @returns True if the system was added successfully\n     */\n    addSystem(system) {\n        // Check if the system is already registered\n        if (this.systems.has(system.id)) {\n            console.warn(`System with ID '${system.id}' is already registered.`);\n            return false;\n        }\n        // Add the system\n        this.systems.set(system.id, system);\n        // Mark as unsorted to trigger re-sorting on the next update\n        this.sorted = false;\n        // Initialize the system\n        system.initialize();\n        return true;\n    }\n    /**\n     * Remove a system from the manager\n     *\n     * @param systemId The ID of the system to remove\n     * @returns True if the system was removed successfully\n     */\n    removeSystem(systemId) {\n        // Check if the system exists\n        const system = this.systems.get(systemId);\n        if (!system) {\n            return false;\n        }\n        // Remove system dependencies\n        this.dependencies = this.dependencies.filter(dep => dep.dependent !== systemId && dep.dependsOn !== systemId);\n        // Destroy the system\n        system.destroy();\n        // Remove the system\n        this.systems.delete(systemId);\n        // Mark as unsorted to trigger re-sorting on the next update\n        this.sorted = false;\n        return true;\n    }\n    /**\n     * Check if a system exists\n     *\n     * @param systemId The ID of the system to check\n     * @returns True if the system exists\n     */\n    hasSystem(systemId) {\n        return this.systems.has(systemId);\n    }\n    /**\n     * Add a dependency between two systems\n     *\n     * @param dependency The dependency to add\n     * @returns True if the dependency was added successfully\n     */\n    addDependency(dependency) {\n        // Verify that both systems exist\n        if (!this.hasSystem(dependency.dependent) || !this.hasSystem(dependency.dependsOn)) {\n            return false;\n        }\n        // Add the dependency\n        this.dependencies.push(dependency);\n        // Mark as unsorted to trigger re-sorting on the next update\n        this.sorted = false;\n        return true;\n    }\n    /**\n     * Sort systems based on priority and dependencies\n     */\n    sortSystems() {\n        if (this.sorted) {\n            return;\n        }\n        // Create a map of systems by priority\n        const systemsByPriority = new Map();\n        // Group systems by priority\n        for (const system of this.systems.values()) {\n            const priority = system.priority;\n            if (!systemsByPriority.has(priority)) {\n                systemsByPriority.set(priority, []);\n            }\n            systemsByPriority.get(priority).push(system);\n        }\n        // Sort priorities in descending order (higher priorities run first)\n        const priorities = Array.from(systemsByPriority.keys()).sort((a, b) => b - a);\n        // Create the ordered list of systems\n        this.orderedSystems = [];\n        // Add systems to the ordered list based on priority\n        for (const priority of priorities) {\n            const systems = systemsByPriority.get(priority);\n            // Sort systems within a priority based on dependencies\n            const sortedSystems = this.topologicalSort(systems);\n            // Add to the ordered list\n            this.orderedSystems.push(...sortedSystems);\n        }\n        this.sorted = true;\n    }\n    /**\n     * Perform a topological sort of systems within a priority based on dependencies\n     *\n     * @param systems The systems to sort\n     * @returns Sorted array of systems\n     */\n    topologicalSort(systems) {\n        // Create a map of system IDs to systems\n        const systemMap = new Map();\n        for (const system of systems) {\n            systemMap.set(system.id, system);\n        }\n        // Create a dependency graph for the systems\n        const graph = new Map();\n        // Initialize each system in the graph with an empty set of dependencies\n        for (const system of systems) {\n            graph.set(system.id, new Set());\n        }\n        // Add dependencies to the graph\n        for (const dependency of this.dependencies) {\n            // Skip dependencies that don't involve these systems\n            if (!systemMap.has(dependency.dependent) || !systemMap.has(dependency.dependsOn)) {\n                continue;\n            }\n            // Add the dependency edge\n            graph.get(dependency.dependent).add(dependency.dependsOn);\n        }\n        // Perform topological sort\n        const visited = new Set();\n        const temp = new Set();\n        const result = [];\n        // Visit function for DFS\n        const visit = (systemId) => {\n            // Skip already visited nodes\n            if (visited.has(systemId)) {\n                return;\n            }\n            // Check for cycle\n            if (temp.has(systemId)) {\n                throw new Error(`Circular dependency detected in systems: ${systemId}`);\n            }\n            // Mark as temporarily visited\n            temp.add(systemId);\n            // Visit all dependencies\n            for (const dependency of graph.get(systemId)) {\n                visit(dependency);\n            }\n            // Mark as visited\n            temp.delete(systemId);\n            visited.add(systemId);\n            // Add to result\n            result.unshift(systemMap.get(systemId));\n        };\n        // Visit each system\n        for (const system of systems) {\n            if (!visited.has(system.id)) {\n                visit(system.id);\n            }\n        }\n        return result;\n    }\n    /**\n     * Update all systems\n     *\n     * @param deltaTime Time elapsed since the last update in seconds\n     */\n    update(deltaTime) {\n        // Sort systems if needed\n        if (!this.sorted) {\n            this.sortSystems();\n        }\n        // Update each system in order\n        for (const system of this.orderedSystems) {\n            if (system.enabled) {\n                system.update(deltaTime);\n            }\n        }\n    }\n    /**\n     * Get all registered systems\n     *\n     * @returns Array of all registered systems\n     */\n    getAllSystems() {\n        return Array.from(this.systems.values());\n    }\n    /**\n     * Get the total number of registered systems\n     *\n     * @returns The number of registered systems\n     */\n    getSystemCount() {\n        return this.systems.size;\n    }\n    /**\n     * Get the number of enabled systems\n     * @returns Number of enabled systems\n     */\n    getEnabledSystemCount() {\n        return Array.from(this.systems.values()).filter(system => system.enabled).length;\n    }\n    /**\n     * Clear all systems\n     */\n    clear() {\n        // Destroy all systems\n        for (const system of this.systems.values()) {\n            system.destroy();\n        }\n        // Clear the collections\n        this.systems.clear();\n        this.dependencies = [];\n        this.orderedSystems = [];\n        this.sorted = true;\n    }\n    /**\n     * Destroy the system manager and all systems\n     */\n    destroy() {\n        this.clear();\n    }\n}\n// Create a global system manager instance\nexport const systemManager = new SystemManager();\n","/**\n * TerraFlux - Entity Component System Core Types\n *\n * This file defines the core types used throughout the ECS implementation.\n */\n/** Entity event types */\nexport var EntityEventType;\n(function (EntityEventType) {\n    EntityEventType[\"CREATED\"] = \"entity_created\";\n    EntityEventType[\"DESTROYED\"] = \"entity_destroyed\";\n    EntityEventType[\"COMPONENT_ADDED\"] = \"component_added\";\n    EntityEventType[\"COMPONENT_REMOVED\"] = \"component_removed\";\n    EntityEventType[\"TAG_ADDED\"] = \"tag_added\";\n    EntityEventType[\"TAG_REMOVED\"] = \"tag_removed\";\n})(EntityEventType || (EntityEventType = {}));\n/** Component storage strategy types */\nexport var ComponentStorageType;\n(function (ComponentStorageType) {\n    /** Array of Structs - Each entity's components are stored together */\n    ComponentStorageType[\"ARRAY_OF_STRUCTS\"] = \"array_of_structs\";\n    /** Struct of Arrays - Each component type is stored in its own array */\n    ComponentStorageType[\"STRUCT_OF_ARRAYS\"] = \"struct_of_arrays\";\n})(ComponentStorageType || (ComponentStorageType = {}));\n/** System update priority levels - Higher values run earlier */\nexport var SystemPriority;\n(function (SystemPriority) {\n    SystemPriority[SystemPriority[\"HIGHEST\"] = 1000] = \"HIGHEST\";\n    SystemPriority[SystemPriority[\"HIGH\"] = 800] = \"HIGH\";\n    SystemPriority[SystemPriority[\"NORMAL\"] = 500] = \"NORMAL\";\n    SystemPriority[SystemPriority[\"LOW\"] = 200] = \"LOW\";\n    SystemPriority[SystemPriority[\"LOWEST\"] = 0] = \"LOWEST\";\n})(SystemPriority || (SystemPriority = {}));\n/** System event types */\nexport var SystemEventType;\n(function (SystemEventType) {\n    SystemEventType[\"INITIALIZED\"] = \"system_initialized\";\n    SystemEventType[\"UPDATED\"] = \"system_updated\";\n    SystemEventType[\"DESTROYED\"] = \"system_destroyed\";\n})(SystemEventType || (SystemEventType = {}));\n","/**\n * TerraFlux - Hex Grid Pathfinding\n *\n * Implements A* pathfinding algorithm for hex grids.\n */\nimport { CoordinateSystem } from '../utils/CoordinateSystem';\n/**\n * Implementation of A* pathfinding algorithm for hex grids\n */\nexport class HexPathfinding {\n    /**\n     * Create a new pathfinding instance\n     *\n     * @param options Configuration options\n     */\n    constructor(options = {}) {\n        var _a, _b, _c, _d;\n        this.maxPathLength = 100;\n        this.allowDiagonal = false;\n        this.maxPathLength = (_a = options.maxPathLength) !== null && _a !== void 0 ? _a : 100;\n        this.terrainCostFn = (_b = options.terrainCostFn) !== null && _b !== void 0 ? _b : (() => 1);\n        this.isObstacleFn = (_c = options.isObstacleFn) !== null && _c !== void 0 ? _c : (() => false);\n        this.allowDiagonal = (_d = options.allowDiagonal) !== null && _d !== void 0 ? _d : false;\n    }\n    /**\n     * Find a path from start to goal hex coordinates\n     *\n     * @param startQ Start q coordinate\n     * @param startR Start r coordinate\n     * @param goalQ Goal q coordinate\n     * @param goalR Goal r coordinate\n     * @returns Array of hex coordinates forming the path, or null if no path found\n     */\n    findPath(startQ, startR, goalQ, goalR) {\n        // Quick check for start == goal\n        if (startQ === goalQ && startR === goalR) {\n            return [{ q: startQ, r: startR }];\n        }\n        // Check if start or goal is an obstacle\n        if (this.isObstacleFn(startQ, startR) || this.isObstacleFn(goalQ, goalR)) {\n            return null;\n        }\n        // Initialize open and closed lists\n        const openList = [];\n        const closedList = new Map();\n        // Create start node\n        const startNode = {\n            q: startQ,\n            r: startR,\n            f: 0,\n            g: 0,\n            h: this.heuristic(startQ, startR, goalQ, goalR),\n            parent: null\n        };\n        // Add start node to open list\n        openList.push(startNode);\n        // Main pathfinding loop\n        while (openList.length > 0) {\n            // Sort open list by f-score (lowest first)\n            openList.sort((a, b) => a.f - b.f);\n            // Get the node with the lowest f-score\n            const currentNode = openList.shift();\n            // Check if we've reached the goal\n            if (currentNode.q === goalQ && currentNode.r === goalR) {\n                return this.reconstructPath(currentNode);\n            }\n            // Add current node to closed list\n            closedList.set(`${currentNode.q},${currentNode.r}`, currentNode);\n            // Get neighboring nodes\n            const neighbors = this.getNeighbors(currentNode.q, currentNode.r);\n            for (const neighbor of neighbors) {\n                // Skip if neighbor is an obstacle or in the closed list\n                if (this.isObstacleFn(neighbor.q, neighbor.r) ||\n                    closedList.has(`${neighbor.q},${neighbor.r}`)) {\n                    continue;\n                }\n                // Calculate g-score for this neighbor\n                const tentativeG = currentNode.g + this.terrainCostFn(neighbor.q, neighbor.r);\n                // Check if neighbor is in open list\n                const existingIndex = openList.findIndex(node => node.q === neighbor.q && node.r === neighbor.r);\n                if (existingIndex === -1) {\n                    // Neighbor is not in open list, add it\n                    const h = this.heuristic(neighbor.q, neighbor.r, goalQ, goalR);\n                    openList.push({\n                        q: neighbor.q,\n                        r: neighbor.r,\n                        g: tentativeG,\n                        h: h,\n                        f: tentativeG + h,\n                        parent: currentNode\n                    });\n                }\n                else if (tentativeG < openList[existingIndex].g) {\n                    // Found a better path to an existing node in the open list\n                    openList[existingIndex].g = tentativeG;\n                    openList[existingIndex].f = tentativeG + openList[existingIndex].h;\n                    openList[existingIndex].parent = currentNode;\n                }\n            }\n            // Check if path is getting too long\n            if (closedList.size > this.maxPathLength) {\n                console.warn(`Pathfinding aborted: Exceeded maximum path length (${this.maxPathLength})`);\n                return null;\n            }\n        }\n        // No path found\n        return null;\n    }\n    /**\n     * Calculate the heuristic (estimated distance) between two hex coordinates\n     *\n     * @param q1 Start q coordinate\n     * @param r1 Start r coordinate\n     * @param q2 Goal q coordinate\n     * @param r2 Goal r coordinate\n     * @returns Estimated distance\n     */\n    heuristic(q1, r1, q2, r2) {\n        return CoordinateSystem.hexDistance(q1, r1, q2, r2);\n    }\n    /**\n     * Get neighboring hex coordinates\n     *\n     * @param q Current q coordinate\n     * @param r Current r coordinate\n     * @returns Array of neighboring coordinates\n     */\n    getNeighbors(q, r) {\n        return CoordinateSystem.getHexNeighbors(q, r);\n    }\n    /**\n     * Reconstruct the path from the goal node\n     *\n     * @param goalNode The goal node with parent references\n     * @returns Array of hex coordinates forming the path\n     */\n    reconstructPath(goalNode) {\n        const path = [];\n        let currentNode = goalNode;\n        // Walk backwards from goal to start\n        while (currentNode !== null) {\n            path.unshift({ q: currentNode.q, r: currentNode.r });\n            currentNode = currentNode.parent;\n        }\n        return path;\n    }\n    /**\n     * Find a path and convert it to world coordinates\n     *\n     * @param startQ Start q coordinate\n     * @param startR Start r coordinate\n     * @param goalQ Goal q coordinate\n     * @param goalR Goal r coordinate\n     * @returns Array of world positions forming the path, or null if no path found\n     */\n    findPathWorld(startQ, startR, goalQ, goalR) {\n        const hexPath = this.findPath(startQ, startR, goalQ, goalR);\n        if (!hexPath) {\n            return null;\n        }\n        // Convert hex coordinates to world coordinates\n        return hexPath.map(hex => CoordinateSystem.hexToWorld(hex.q, hex.r));\n    }\n    /**\n     * Smooth a path to remove unnecessary zigzags\n     *\n     * @param path The original path\n     * @returns Smoothed path\n     */\n    smoothPath(path) {\n        if (path.length <= 2) {\n            return [...path]; // No need to smooth paths of length 0, 1, or 2\n        }\n        const smoothed = [path[0]]; // Start with the first point\n        let current = 0;\n        // Keep examining paths until we reach the end\n        while (current < path.length - 1) {\n            // Find the furthest point we can see directly\n            let furthest = current + 1;\n            for (let i = current + 2; i < path.length; i++) {\n                if (this.hasLineOfSight(path[current].q, path[current].r, path[i].q, path[i].r)) {\n                    furthest = i;\n                }\n            }\n            // Add the furthest visible point to our smoothed path\n            if (furthest !== current) {\n                smoothed.push(path[furthest]);\n                current = furthest;\n            }\n            else {\n                current++;\n            }\n        }\n        return smoothed;\n    }\n    /**\n     * Check if there is a clear line of sight between two hex coordinates\n     *\n     * @param startQ Start q coordinate\n     * @param startR Start r coordinate\n     * @param endQ End q coordinate\n     * @param endR End r coordinate\n     * @returns True if there is a clear line of sight\n     */\n    hasLineOfSight(startQ, startR, endQ, endR) {\n        // Use Bresenham's line algorithm adapted for hex grids\n        const line = this.getHexLine(startQ, startR, endQ, endR);\n        // Check if any point in the line is an obstacle\n        for (let i = 1; i < line.length - 1; i++) {\n            if (this.isObstacleFn(line[i].q, line[i].r)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Get a line of hex coordinates between two hex coordinates\n     *\n     * @param startQ Start q coordinate\n     * @param startR Start r coordinate\n     * @param endQ End q coordinate\n     * @param endR End r coordinate\n     * @returns Array of hex coordinates forming a line\n     */\n    getHexLine(startQ, startR, endQ, endR) {\n        const N = CoordinateSystem.hexDistance(startQ, startR, endQ, endR);\n        if (N === 0) {\n            return [{ q: startQ, r: startR }];\n        }\n        const results = [];\n        // Convert to cube coordinates for linear interpolation\n        const startS = -startQ - startR;\n        const endS = -endQ - endR;\n        for (let i = 0; i <= N; i++) {\n            const t = i / N;\n            // Linear interpolation in cube coordinates\n            const q = startQ + (endQ - startQ) * t;\n            const r = startR + (endR - startR) * t;\n            const s = startS + (endS - startS) * t;\n            // Round to get exact hex coordinates\n            const [roundedQ, roundedR] = CoordinateSystem.cubeRound(q, r, s);\n            results.push({ q: roundedQ, r: roundedR });\n        }\n        return results;\n    }\n}\n","/**\n * TerraFlux - Coordinate System\n *\n * Handles conversions between different coordinate systems:\n * - Hex Coordinates (q, r): Used for the world map\n * - World Coordinates (x, y): Used for rendering in world space\n * - Grid Coordinates (x, y): Used for colony grid-based positioning\n */\n/**\n * Coordinate system utility for handling conversions between different coordinate systems\n */\nexport class CoordinateSystem {\n    /**\n     * Convert hex coordinates to world position\n     *\n     * @param q The q coordinate (axial system)\n     * @param r The r coordinate (axial system)\n     * @returns World position as {x, y}\n     */\n    static hexToWorld(q, r) {\n        const x = this.HEX_SIZE * (Math.sqrt(3) * q + Math.sqrt(3) / 2 * r);\n        const y = this.HEX_SIZE * (3 / 2 * r);\n        return { x, y };\n    }\n    /**\n     * Convert world position to hex coordinates\n     *\n     * @param x X coordinate in world space\n     * @param y Y coordinate in world space\n     * @returns Hex coordinates as {q, r}\n     */\n    static worldToHex(x, y) {\n        const r = y * 2 / 3 / this.HEX_SIZE;\n        const q = (x - Math.sqrt(3) / 2 * r * this.HEX_SIZE) / (Math.sqrt(3) * this.HEX_SIZE);\n        // Round to nearest hex\n        const [q_rounded, r_rounded] = this.cubeRound(q, r, -q - r);\n        return { q: q_rounded, r: r_rounded };\n    }\n    /**\n     * Convert cube coordinates to axial coordinates with proper rounding\n     * This ensures we get exact hex coordinates even with floating point inputs\n     *\n     * @param q Floating point q coordinate\n     * @param r Floating point r coordinate\n     * @param s Floating point s coordinate\n     * @returns Rounded [q, r] coordinates\n     */\n    static cubeRound(q, r, s) {\n        let rx = Math.round(q);\n        let ry = Math.round(r);\n        let rz = Math.round(s);\n        const x_diff = Math.abs(rx - q);\n        const y_diff = Math.abs(ry - r);\n        const z_diff = Math.abs(rz - s);\n        // Adjust based on largest delta to maintain q + r + s = 0\n        if (x_diff > y_diff && x_diff > z_diff) {\n            rx = -ry - rz;\n        }\n        else if (y_diff > z_diff) {\n            ry = -rx - rz;\n        }\n        else {\n            rz = -rx - ry;\n        }\n        return [rx, ry];\n    }\n    /**\n     * Convert grid coordinates to world position\n     *\n     * @param x X coordinate in grid space\n     * @param y Y coordinate in grid space\n     * @returns World position as {x, y}\n     */\n    static gridToWorld(x, y) {\n        return {\n            x: x * this.GRID_SIZE,\n            y: y * this.GRID_SIZE\n        };\n    }\n    /**\n     * Convert world position to grid coordinates\n     *\n     * @param x X coordinate in world space\n     * @param y Y coordinate in world space\n     * @returns Grid coordinates as {x, y}\n     */\n    static worldToGrid(x, y) {\n        return {\n            x: Math.floor(x / this.GRID_SIZE),\n            y: Math.floor(y / this.GRID_SIZE)\n        };\n    }\n    /**\n     * Convert directly from hex coordinates to grid coordinates\n     *\n     * @param q The q coordinate (axial system)\n     * @param r The r coordinate (axial system)\n     * @returns Grid coordinates as {x, y}\n     */\n    static hexToGrid(q, r) {\n        const worldPos = this.hexToWorld(q, r);\n        return this.worldToGrid(worldPos.x, worldPos.y);\n    }\n    /**\n     * Convert directly from grid coordinates to hex coordinates\n     *\n     * @param x X coordinate in grid space\n     * @param y Y coordinate in grid space\n     * @returns Hex coordinates as {q, r}\n     */\n    static gridToHex(x, y) {\n        const worldPos = this.gridToWorld(x, y);\n        return this.worldToHex(worldPos.x, worldPos.y);\n    }\n    /**\n     * Calculate distance between two hex coordinates\n     *\n     * @param q1 First hex q coordinate\n     * @param r1 First hex r coordinate\n     * @param q2 Second hex q coordinate\n     * @param r2 Second hex r coordinate\n     * @returns Distance in hex units\n     */\n    static hexDistance(q1, r1, q2, r2) {\n        // Convert to cube coordinates\n        const s1 = -q1 - r1;\n        const s2 = -q2 - r2;\n        // Calculate distance using cube coordinates\n        return Math.max(Math.abs(q1 - q2), Math.abs(r1 - r2), Math.abs(s1 - s2));\n    }\n    /**\n     * Get all neighboring hex coordinates\n     *\n     * @param q The q coordinate\n     * @param r The r coordinate\n     * @returns Array of neighboring hex coordinates\n     */\n    static getHexNeighbors(q, r) {\n        // Directions for neighboring hexes in axial coordinates\n        const directions = [\n            { q: 1, r: 0 },\n            { q: 1, r: -1 },\n            { q: 0, r: -1 },\n            { q: -1, r: 0 },\n            { q: -1, r: 1 },\n            { q: 0, r: 1 }\n        ];\n        return directions.map(dir => ({\n            q: q + dir.q,\n            r: r + dir.r\n        }));\n    }\n    /**\n     * Get hex coordinates in a ring around a center\n     *\n     * @param centerQ Center hex q coordinate\n     * @param centerR Center hex r coordinate\n     * @param radius Radius of the ring\n     * @returns Array of hex coordinates forming a ring\n     */\n    static getHexRing(centerQ, centerR, radius) {\n        if (radius === 0) {\n            return [{ q: centerQ, r: centerR }];\n        }\n        const results = [];\n        // Start at the southwest corner\n        let q = centerQ - 0;\n        let r = centerR + radius;\n        // Direction vectors for moving around the ring\n        const directions = [\n            { q: 1, r: -1 }, // Northeast\n            { q: 1, r: 0 }, // East\n            { q: 0, r: 1 }, // Southeast\n            { q: -1, r: 1 }, // Southwest\n            { q: -1, r: 0 }, // West\n            { q: 0, r: -1 } // Northwest\n        ];\n        // For each side of the ring\n        for (let side = 0; side < 6; side++) {\n            // Move along one side\n            for (let i = 0; i < radius; i++) {\n                results.push({ q, r });\n                q += directions[side].q;\n                r += directions[side].r;\n            }\n        }\n        return results;\n    }\n    /**\n     * Get all hex coordinates within a certain radius of a center point\n     *\n     * @param centerQ Center hex q coordinate\n     * @param centerR Center hex r coordinate\n     * @param radius Maximum distance from center\n     * @returns Array of hex coordinates within the radius\n     */\n    static getHexesInRadius(centerQ, centerR, radius) {\n        const results = [];\n        for (let q = centerQ - radius; q <= centerQ + radius; q++) {\n            // Calculate r bounds based on hex grid geometry\n            const rMin = Math.max(centerR - radius, -q - radius + centerQ + centerR);\n            const rMax = Math.min(centerR + radius, -q + radius + centerQ + centerR);\n            for (let r = rMin; r <= rMax; r++) {\n                results.push({ q, r });\n            }\n        }\n        return results;\n    }\n    /**\n     * Get the size of a hex in world units\n     *\n     * @returns The hex size\n     */\n    static getHexSize() {\n        return this.HEX_SIZE;\n    }\n    /**\n     * Get the grid cell size in world units\n     *\n     * @returns The grid size\n     */\n    static getGridSize() {\n        return this.GRID_SIZE;\n    }\n}\n/**\n * Size of a hex in world units\n * This affects the scale of the rendered hexagons\n */\nCoordinateSystem.HEX_SIZE = 64;\n/**\n * Size of a grid cell in world units\n * This affects the scale of the grid-based colony system\n */\nCoordinateSystem.GRID_SIZE = 32;\n","/**\n * TerraFlux - Coordinate System Verification\n *\n * This utility verifies that coordinate conversions work correctly.\n * It performs a series of round-trip conversions and checks for accuracy.\n * Used to satisfy Checkpoint 2.3 in the masterplan.\n */\nimport { CoordinateSystem } from './CoordinateSystem';\n/**\n * Class to verify coordinate conversions work correctly\n */\nexport class CoordinateSystemVerification {\n    /**\n     * Run all verification tests\n     */\n    static runAllTests() {\n        console.log('===== Coordinate System Verification Tests =====');\n        const tests = [\n            this.testHexToWorldAndBack,\n            this.testGridToWorldAndBack,\n            this.testHexToGridAndBack,\n            this.testNeighborsConsistency,\n            this.testHexDistanceProperties,\n            this.testRingGeneration,\n            this.testRadiusGeneration\n        ];\n        let allPassed = true;\n        for (const test of tests) {\n            const passed = test();\n            allPassed = allPassed && passed;\n            console.log(`${test.name}: ${passed ? 'PASSED' : 'FAILED'}`);\n        }\n        console.log(`===== Overall Result: ${allPassed ? 'ALL TESTS PASSED' : 'SOME TESTS FAILED'} =====`);\n        return allPassed;\n    }\n    /**\n     * Test conversion from hex to world and back\n     */\n    static testHexToWorldAndBack() {\n        // Test a range of hex coordinates\n        const testCoords = [\n            { q: 0, r: 0 },\n            { q: 1, r: 0 },\n            { q: 0, r: 1 },\n            { q: -1, r: 0 },\n            { q: 0, r: -1 },\n            { q: 5, r: -3 },\n            { q: -7, r: 4 }\n        ];\n        for (const hex of testCoords) {\n            // Convert hex to world\n            const world = CoordinateSystem.hexToWorld(hex.q, hex.r);\n            // Convert world back to hex\n            const hexBack = CoordinateSystem.worldToHex(world.x, world.y);\n            // Check if we got the original coordinates back\n            if (hexBack.q !== hex.q || hexBack.r !== hex.r) {\n                console.error(`Hex-World-Hex conversion failed for ${JSON.stringify(hex)}`);\n                console.error(`  World: ${JSON.stringify(world)}`);\n                console.error(`  Hex back: ${JSON.stringify(hexBack)}`);\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Test conversion from grid to world and back\n     */\n    static testGridToWorldAndBack() {\n        // Test a range of grid coordinates\n        const testCoords = [\n            { x: 0, y: 0 },\n            { x: 1, y: 0 },\n            { x: 0, y: 1 },\n            { x: -1, y: 0 },\n            { x: 0, y: -1 },\n            { x: 10, y: -5 },\n            { x: -8, y: 12 }\n        ];\n        for (const grid of testCoords) {\n            // Convert grid to world\n            const world = CoordinateSystem.gridToWorld(grid.x, grid.y);\n            // Convert world back to grid\n            const gridBack = CoordinateSystem.worldToGrid(world.x, world.y);\n            // Check if we got the original coordinates back\n            if (gridBack.x !== grid.x || gridBack.y !== grid.y) {\n                console.error(`Grid-World-Grid conversion failed for ${JSON.stringify(grid)}`);\n                console.error(`  World: ${JSON.stringify(world)}`);\n                console.error(`  Grid back: ${JSON.stringify(gridBack)}`);\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Test conversion from hex to grid and back\n     */\n    static testHexToGridAndBack() {\n        // Test a range of hex coordinates\n        const testCoords = [\n            { q: 0, r: 0 },\n            { q: 1, r: 0 },\n            { q: 0, r: 1 },\n            { q: -1, r: 0 },\n            { q: 0, r: -1 },\n            { q: 5, r: -3 },\n            { q: -7, r: 4 }\n        ];\n        for (const hex of testCoords) {\n            // Convert hex to grid\n            const grid = CoordinateSystem.hexToGrid(hex.q, hex.r);\n            // Convert grid to world (intermediate step)\n            const world = CoordinateSystem.gridToWorld(grid.x, grid.y);\n            // Convert world back to hex\n            const hexBack = CoordinateSystem.worldToHex(world.x, world.y);\n            // This conversion might not be exact due to grid quantization\n            // but should be close - within 1 hex distance\n            const distance = CoordinateSystem.hexDistance(hex.q, hex.r, hexBack.q, hexBack.r);\n            if (distance > 1) {\n                console.error(`Hex-Grid-Hex conversion too far off for ${JSON.stringify(hex)}`);\n                console.error(`  Grid: ${JSON.stringify(grid)}`);\n                console.error(`  Hex back: ${JSON.stringify(hexBack)}`);\n                console.error(`  Distance: ${distance}`);\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Test that hex neighbors are consistent\n     */\n    static testNeighborsConsistency() {\n        // Test that all neighbors are exactly distance 1 away\n        const hex = { q: 3, r: -2 };\n        const neighbors = CoordinateSystem.getHexNeighbors(hex.q, hex.r);\n        // Check each neighbor\n        for (const neighbor of neighbors) {\n            const distance = CoordinateSystem.hexDistance(hex.q, hex.r, neighbor.q, neighbor.r);\n            if (distance !== 1) {\n                console.error(`Neighbor not at distance 1: ${JSON.stringify(neighbor)}`);\n                console.error(`  Distance: ${distance}`);\n                return false;\n            }\n        }\n        // Check that we have exactly 6 neighbors\n        if (neighbors.length !== 6) {\n            console.error(`Wrong number of neighbors: ${neighbors.length} (expected 6)`);\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test hex distance properties\n     */\n    static testHexDistanceProperties() {\n        // Test distance properties\n        const hexes = [\n            { q: 0, r: 0 },\n            { q: 3, r: -2 },\n            { q: -1, r: 5 },\n            { q: 7, r: 0 }\n        ];\n        // Test symmetry: d(a,b) = d(b,a)\n        for (let i = 0; i < hexes.length; i++) {\n            for (let j = i + 1; j < hexes.length; j++) {\n                const a = hexes[i];\n                const b = hexes[j];\n                const d1 = CoordinateSystem.hexDistance(a.q, a.r, b.q, b.r);\n                const d2 = CoordinateSystem.hexDistance(b.q, b.r, a.q, a.r);\n                if (d1 !== d2) {\n                    console.error(`Distance not symmetric: d(${JSON.stringify(a)}, ${JSON.stringify(b)}) = ${d1}, but d(${JSON.stringify(b)}, ${JSON.stringify(a)}) = ${d2}`);\n                    return false;\n                }\n            }\n        }\n        // Test triangle inequality: d(a,c) <= d(a,b) + d(b,c)\n        for (let i = 0; i < hexes.length; i++) {\n            for (let j = 0; j < hexes.length; j++) {\n                if (i === j)\n                    continue;\n                for (let k = 0; k < hexes.length; k++) {\n                    if (i === k || j === k)\n                        continue;\n                    const a = hexes[i];\n                    const b = hexes[j];\n                    const c = hexes[k];\n                    const dac = CoordinateSystem.hexDistance(a.q, a.r, c.q, c.r);\n                    const dab = CoordinateSystem.hexDistance(a.q, a.r, b.q, b.r);\n                    const dbc = CoordinateSystem.hexDistance(b.q, b.r, c.q, c.r);\n                    if (dac > dab + dbc) {\n                        console.error(`Triangle inequality violated: d(${JSON.stringify(a)}, ${JSON.stringify(c)}) = ${dac} > ${dab} + ${dbc} = d(${JSON.stringify(a)}, ${JSON.stringify(b)}) + d(${JSON.stringify(b)}, ${JSON.stringify(c)})`);\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    /**\n     * Test hex ring generation\n     */\n    static testRingGeneration() {\n        const center = { q: 0, r: 0 };\n        // Test rings of different radii\n        for (let radius = 1; radius <= 3; radius++) {\n            const ring = CoordinateSystem.getHexRing(center.q, center.r, radius);\n            // Check that all hexes in the ring are at the correct distance from center\n            for (const hex of ring) {\n                const distance = CoordinateSystem.hexDistance(center.q, center.r, hex.q, hex.r);\n                if (distance !== radius) {\n                    console.error(`Hex in ring at wrong distance: ${JSON.stringify(hex)}`);\n                    console.error(`  Expected distance: ${radius}, actual: ${distance}`);\n                    return false;\n                }\n            }\n            // Check that the ring has the correct number of hexes\n            // A ring of radius r should have 6*r hexes\n            if (ring.length !== 6 * radius) {\n                console.error(`Ring has wrong number of hexes: ${ring.length} (expected ${6 * radius})`);\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Test hex radius generation\n     */\n    static testRadiusGeneration() {\n        const center = { q: 0, r: 0 };\n        // Test hexes within different radii\n        for (let radius = 1; radius <= 3; radius++) {\n            const hexes = CoordinateSystem.getHexesInRadius(center.q, center.r, radius);\n            // Check that all hexes are within the correct distance from center\n            for (const hex of hexes) {\n                const distance = CoordinateSystem.hexDistance(center.q, center.r, hex.q, hex.r);\n                if (distance > radius) {\n                    console.error(`Hex outside radius: ${JSON.stringify(hex)}`);\n                    console.error(`  Maximum allowed distance: ${radius}, actual: ${distance}`);\n                    return false;\n                }\n            }\n            // Check that the number of hexes is correct\n            // The number of hexes within radius r is 1 + 3r(r+1)\n            const expectedCount = 1 + 3 * radius * (radius + 1);\n            if (hexes.length !== expectedCount) {\n                console.error(`Radius has wrong number of hexes: ${hexes.length} (expected ${expectedCount})`);\n                return false;\n            }\n        }\n        return true;\n    }\n}\n","/**\n * TerraFlux - Type Registry\n *\n * A type-safe registry for component types and other game object types.\n * Allows for registration, lookup, and validation of types by ID or name.\n */\nimport { UUID } from './UUID';\n/**\n * Generic type registry for managing registrations of any type\n */\nexport class TypeRegistry {\n    constructor() {\n        /**\n         * Maps type IDs to their registration details\n         */\n        this.registry = new Map();\n        /**\n         * Maps type names to their IDs for name-based lookups\n         */\n        this.nameIndex = new Map();\n    }\n    /**\n     * Register a new type\n     *\n     * @param type The type to register\n     * @returns The same type (for chaining)\n     * @throws Error if a type with the same ID is already registered\n     */\n    register(type) {\n        // Check if already registered\n        if (this.registry.has(type.id)) {\n            throw new Error(`Type with ID '${type.id}' is already registered.`);\n        }\n        // Check for conflicting name\n        if (this.nameIndex.has(type.name)) {\n            throw new Error(`Type with name '${type.name}' is already registered with ID '${this.nameIndex.get(type.name)}'.`);\n        }\n        // Add to registry and index by name\n        this.registry.set(type.id, type);\n        this.nameIndex.set(type.name, type.id);\n        return type;\n    }\n    /**\n     * Get a type by its ID\n     *\n     * @param id The ID of the type to retrieve\n     * @returns The registered type or undefined if not found\n     */\n    getById(id) {\n        return this.registry.get(id);\n    }\n    /**\n     * Get a type by its name\n     *\n     * @param name The name of the type to retrieve\n     * @returns The registered type or undefined if not found\n     */\n    getByName(name) {\n        const id = this.nameIndex.get(name);\n        return id ? this.registry.get(id) : undefined;\n    }\n    /**\n     * Check if a type with the given ID is registered\n     *\n     * @param id The ID to check\n     * @returns True if a type with the given ID is registered\n     */\n    hasId(id) {\n        return this.registry.has(id);\n    }\n    /**\n     * Check if a type with the given name is registered\n     *\n     * @param name The name to check\n     * @returns True if a type with the given name is registered\n     */\n    hasName(name) {\n        return this.nameIndex.has(name);\n    }\n    /**\n     * Unregister a type by ID\n     *\n     * @param id The ID of the type to unregister\n     * @returns True if the type was successfully unregistered\n     */\n    unregister(id) {\n        const type = this.registry.get(id);\n        if (!type) {\n            return false;\n        }\n        // Remove from name index\n        this.nameIndex.delete(type.name);\n        // Remove from registry\n        return this.registry.delete(id);\n    }\n    /**\n     * Get all registered types\n     *\n     * @returns Array of all registered types\n     */\n    getAll() {\n        return Array.from(this.registry.values());\n    }\n    /**\n     * Get the number of registered types\n     *\n     * @returns The number of registered types\n     */\n    get count() {\n        return this.registry.size;\n    }\n    /**\n     * Clear all registered types\n     */\n    clear() {\n        this.registry.clear();\n        this.nameIndex.clear();\n    }\n}\n/**\n * Registry specifically for component types\n */\nexport class ComponentRegistry extends TypeRegistry {\n    /**\n     * Register a new component type with automatic ID generation\n     *\n     * @param name Human-readable component name\n     * @param createFn Factory function to create new instances\n     * @returns The registered component type\n     */\n    registerComponentType(name, createFn) {\n        // Generate a stable ID based on the component name\n        const id = UUID.generateComponentId(name);\n        // Create the component type descriptor\n        const componentType = {\n            id,\n            name,\n            create: createFn\n        };\n        // Register it in the base registry\n        return this.register(componentType);\n    }\n    /**\n     * Create a new instance of a component by type name\n     *\n     * @param name The name of the component type\n     * @returns A new component instance or undefined if type not found\n     */\n    createByName(name) {\n        const componentType = this.getByName(name);\n        return componentType ? componentType.create() : undefined;\n    }\n    /**\n     * Create a new instance of a component by type ID\n     *\n     * @param id The ID of the component type\n     * @returns A new component instance or undefined if type not found\n     */\n    createById(id) {\n        const componentType = this.getById(id);\n        return componentType ? componentType.create() : undefined;\n    }\n}\n// Create a global instance of the component registry\nexport const componentRegistry = new ComponentRegistry();\n","/**\n * TerraFlux - UUID Generator\n *\n * A utility for generating unique identifiers for entities and components.\n * Uses a combination of timestamp, random values, and counter to ensure uniqueness,\n * even when generated in rapid succession.\n */\nexport class UUID {\n    /**\n     * Generate a unique identifier string\n     * Format: timestamp-random-counter\n     *\n     * @returns A string UUID that is guaranteed to be unique\n     */\n    static generate() {\n        // Get current timestamp\n        let timestamp = Date.now();\n        // Check for clock drift or multiple calls within same millisecond\n        if (timestamp <= UUID.lastTimestamp) {\n            // Use the last timestamp and increment counter to ensure uniqueness\n            timestamp = UUID.lastTimestamp;\n            UUID.counter++;\n        }\n        else {\n            // New millisecond, reset counter\n            UUID.counter = 0;\n            UUID.lastTimestamp = timestamp;\n        }\n        // Generate a random part\n        const random = Math.floor(Math.random() * 0x100000).toString(16).padStart(5, '0');\n        // Format: base36 timestamp + random hex + counter\n        return `${timestamp.toString(36)}-${random}-${UUID.counter.toString(36)}`;\n    }\n    /**\n     * Generate a unique identifier with a specific prefix\n     * Useful for debugging and identifying entity types\n     *\n     * @param prefix A string prefix to prepend to the UUID\n     * @returns A prefixed unique identifier\n     */\n    static generateWithPrefix(prefix) {\n        return `${prefix}-${UUID.generate()}`;\n    }\n    /**\n     * Generate an entity ID with an optional type hint\n     *\n     * @param entityType Optional type hint for debugging\n     * @returns Entity ID string\n     */\n    static generateEntityId(entityType) {\n        return entityType\n            ? UUID.generateWithPrefix(`ent-${entityType}`)\n            : UUID.generateWithPrefix('ent');\n    }\n    /**\n     * Generate a component type ID\n     *\n     * @param componentName The name of the component\n     * @returns Component type ID string\n     */\n    static generateComponentId(componentName) {\n        // Clean the component name to make it URL-safe\n        const safeName = componentName\n            .toLowerCase()\n            .replace(/[^a-z0-9]/g, '_');\n        return `comp-${safeName}-${UUID.generate()}`;\n    }\n    /**\n     * Generate a system ID\n     *\n     * @param systemName The name of the system\n     * @returns System ID string\n     */\n    static generateSystemId(systemName) {\n        // Clean the system name to make it URL-safe\n        const safeName = systemName\n            .toLowerCase()\n            .replace(/[^a-z0-9]/g, '_');\n        return `sys-${safeName}-${UUID.generate()}`;\n    }\n    /**\n     * Validate if a string is a properly formatted UUID\n     *\n     * @param id The string to validate\n     * @returns True if the string is a valid UUID format\n     */\n    static isValid(id) {\n        // Basic validation for our UUID format\n        return /^[a-z]+-[a-z0-9]+-[a-z0-9]{5}-[a-z0-9]+$/.test(id);\n    }\n}\n// Counter to ensure uniqueness for multiple IDs generated within the same millisecond\nUUID.counter = 0;\n// Last timestamp used - to detect clock issues and ensure ascending order\nUUID.lastTimestamp = 0;\n","/**\n * TerraFlux - Game Example\n *\n * A simple example demonstrating the ECS architecture.\n * Creates bouncing entities with position and velocity components\n * managed by a movement system.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { game, GameEventType } from '../core/Game';\nimport { entityManager } from '../core/ecs/EntityManager';\nimport { systemManager } from '../core/ecs/SystemManager';\nimport { SystemPriority } from '../core/ecs/types';\nimport { PositionComponent } from '../components/Position';\nimport { VelocityComponent } from '../components/Velocity';\nimport { MovementSystem } from '../systems/MovementSystem';\n// Game area boundaries\nconst GAME_WIDTH = 800;\nconst GAME_HEIGHT = 600;\nconst ENTITY_SIZE = 20;\n// Entity bounce system\nclass BounceSystem extends MovementSystem {\n    constructor() {\n        super({\n            name: 'Bounce',\n            // Use a higher priority to ensure it runs after movement\n            priority: SystemPriority.HIGH\n        });\n    }\n    onUpdate(deltaTime, entities) {\n        // First let movement system update positions\n        super.onUpdate(deltaTime, entities);\n        // Then handle bouncing off walls\n        for (const entity of entities) {\n            const position = entity.getComponent('position');\n            const velocity = entity.getComponent('velocity');\n            if (position && velocity) {\n                // Bounce off left/right walls\n                if (position.x < 0) {\n                    position.x = 0;\n                    velocity.vx = Math.abs(velocity.vx);\n                }\n                else if (position.x > GAME_WIDTH - ENTITY_SIZE) {\n                    position.x = GAME_WIDTH - ENTITY_SIZE;\n                    velocity.vx = -Math.abs(velocity.vx);\n                }\n                // Bounce off top/bottom walls\n                if (position.y < 0) {\n                    position.y = 0;\n                    velocity.vy = Math.abs(velocity.vy);\n                }\n                else if (position.y > GAME_HEIGHT - ENTITY_SIZE) {\n                    position.y = GAME_HEIGHT - ENTITY_SIZE;\n                    velocity.vy = -Math.abs(velocity.vy);\n                }\n            }\n        }\n    }\n}\n// Renderer system - just logs positions, would normally draw entities\nclass RenderSystem {\n    constructor() {\n        this.canvas = null;\n        this.context = null;\n        // Initialize canvas when document is ready\n        document.addEventListener('DOMContentLoaded', () => {\n            this.initCanvas();\n        });\n    }\n    initCanvas() {\n        var _a;\n        // Create canvas if it doesn't exist\n        if (!this.canvas) {\n            this.canvas = document.createElement('canvas');\n            this.canvas.width = GAME_WIDTH;\n            this.canvas.height = GAME_HEIGHT;\n            this.canvas.style.border = '1px solid black';\n            this.canvas.style.backgroundColor = '#f0f0f0';\n            (_a = document.getElementById('game-container')) === null || _a === void 0 ? void 0 : _a.appendChild(this.canvas);\n            // Get context\n            this.context = this.canvas.getContext('2d');\n        }\n    }\n    render(entities) {\n        if (!this.context || !this.canvas) {\n            this.initCanvas();\n            if (!this.context)\n                return;\n        }\n        // Clear canvas\n        this.context.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);\n        // Draw each entity\n        for (const entity of entities) {\n            const position = entity.getComponent('position');\n            if (position) {\n                // Draw entity\n                this.context.fillStyle = entity.hasTag('player') ? 'blue' : 'red';\n                this.context.fillRect(position.x, position.y, ENTITY_SIZE, ENTITY_SIZE);\n                // Draw entity name\n                this.context.fillStyle = 'black';\n                this.context.font = '10px Arial';\n                this.context.fillText(entity.name, position.x, position.y - 5);\n            }\n        }\n    }\n}\n/**\n * Game Example class\n */\nexport class GameExample {\n    constructor() {\n        this.renderer = new RenderSystem();\n        // Set up event listeners\n        game.eventEmitter.subscribe(GameEventType.INITIALIZED, this.onGameInitialized.bind(this));\n        game.eventEmitter.subscribe(GameEventType.UPDATE, this.onGameUpdate.bind(this));\n    }\n    /**\n     * Initialize the game example\n     */\n    init() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Configure and initialize the game\n            game.debug = true;\n            game.targetFPS = 60;\n            game.useFixedTimestep = false; // Use variable timestep by default\n            game.timeScale = 1.0; // Normal speed\n            yield game.initialize();\n            // Create systems\n            const bounceSystem = new BounceSystem();\n            systemManager.addSystem(bounceSystem);\n            // Create entities\n            this.createEntities();\n            // Set up event listeners for game loop changes\n            game.eventEmitter.subscribe(GameEventType.TIME_SCALE_CHANGED, this.onTimeScaleChanged.bind(this));\n            game.eventEmitter.subscribe(GameEventType.TIMESTEP_MODE_CHANGED, this.onTimestepModeChanged.bind(this));\n            game.eventEmitter.subscribe(GameEventType.PERFORMANCE_SNAPSHOT, this.onPerformanceSnapshot.bind(this));\n            // Start the game\n            game.start();\n            console.log('Game example initialized with', entityManager.getEntityCount(), 'entities');\n            return game;\n        });\n    }\n    /**\n     * Called when the time scale changes\n     */\n    onTimeScaleChanged(game, timeScale) {\n        console.log(`Time scale changed to ${timeScale.toFixed(1)}x`);\n        // We could use this to visually indicate the current speed\n        // For example, changing a UI element or adjusting animations\n    }\n    /**\n     * Called when the timestep mode changes\n     */\n    onTimestepModeChanged(game, useFixedTimestep) {\n        console.log(`Switched to ${useFixedTimestep ? 'fixed' : 'variable'} timestep mode`);\n        // Could adjust UI or physics behavior based on timestep mode\n    }\n    /**\n     * Called when a performance snapshot is taken\n     */\n    onPerformanceSnapshot(game, snapshot) {\n        console.log('Performance snapshot:', snapshot);\n        // Could display detailed performance metrics in a UI\n    }\n    /**\n     * Called when the game is initialized\n     */\n    onGameInitialized() {\n        console.log('Game initialized!');\n    }\n    /**\n     * Called every frame\n     */\n    onGameUpdate(game, deltaTime) {\n        // Get all entities with position components\n        const entities = entityManager.getEntitiesWithComponent('position');\n        // Render entities\n        this.renderer.render(entities);\n    }\n    /**\n     * Create initial entities\n     */\n    createEntities() {\n        // Create player entity\n        const player = entityManager.createEntity({ name: 'Player' });\n        player.addTag('player');\n        // Add components to player\n        entityManager.addComponent(player.id, new PositionComponent(GAME_WIDTH / 2, GAME_HEIGHT / 2));\n        entityManager.addComponent(player.id, new VelocityComponent(100, 130));\n        // Create some random entities\n        for (let i = 0; i < 10; i++) {\n            const entity = entityManager.createEntity({ name: `Entity ${i + 1}` });\n            // Random position within game area\n            const x = Math.random() * (GAME_WIDTH - ENTITY_SIZE);\n            const y = Math.random() * (GAME_HEIGHT - ENTITY_SIZE);\n            // Random velocity\n            const vx = (Math.random() - 0.5) * 200;\n            const vy = (Math.random() - 0.5) * 200;\n            // Add components\n            entityManager.addComponent(entity.id, new PositionComponent(x, y));\n            entityManager.addComponent(entity.id, new VelocityComponent(vx, vy));\n        }\n    }\n}\n// Export an instance of the game example for easy access\nexport const gameExample = new GameExample();\n","/**\n * TerraFlux - Movement System\n *\n * Updates entity positions based on their velocities.\n */\nimport { System } from '../core/ecs/System';\nimport { POSITION_COMPONENT_ID } from '../components/Position';\nimport { VELOCITY_COMPONENT_ID } from '../components/Velocity';\nimport { SystemPriority } from '../core/ecs/types';\n/**\n * System that updates entity positions based on velocities\n */\nexport class MovementSystem extends System {\n    /**\n     * Constructor for MovementSystem\n     *\n     * @param config System configuration\n     */\n    constructor(config = {}) {\n        super(Object.assign({ name: 'Movement', priority: SystemPriority.NORMAL, query: {\n                withComponents: [POSITION_COMPONENT_ID, VELOCITY_COMPONENT_ID]\n            } }, config));\n    }\n    /**\n     * Called during system initialization\n     */\n    onInitialize() {\n        console.log(`[${this.name}] Initialized`);\n        return true;\n    }\n    /**\n     * Update method called each frame for entities with position and velocity\n     *\n     * @param deltaTime Time elapsed since the last update in seconds\n     * @param entities Array of entities that match this system's query\n     */\n    onUpdate(deltaTime, entities) {\n        // Process all matching entities\n        for (const entity of entities) {\n            // Get the position and velocity components\n            const position = entity.getComponent(POSITION_COMPONENT_ID);\n            const velocity = entity.getComponent(VELOCITY_COMPONENT_ID);\n            if (position && velocity) {\n                // Update position based on velocity and delta time\n                position.x += velocity.vx * deltaTime;\n                position.y += velocity.vy * deltaTime;\n            }\n        }\n    }\n    /**\n     * Called when the system is enabled\n     */\n    onEnable() {\n        console.log(`[${this.name}] Enabled`);\n    }\n    /**\n     * Called when the system is disabled\n     */\n    onDisable() {\n        console.log(`[${this.name}] Disabled`);\n    }\n    /**\n     * Called when the system is destroyed\n     */\n    onDestroy() {\n        console.log(`[${this.name}] Destroyed`);\n    }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * TerraFlux - Game Entry Point\n *\n * Main entry point for initializing the game within the Electron application.\n * This file serves as the bridge between the Electron IPC system and the game engine.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { gameExample } from './example/GameExample';\nimport { game, GameEventType } from './core/Game';\n/**\n * Initialize game when the DOM is ready\n */\ndocument.addEventListener('DOMContentLoaded', () => {\n    console.log('Game DOM ready, waiting for init event from Electron');\n    // Create game container for rendering\n    const container = document.createElement('div');\n    container.id = 'game-container';\n    container.style.width = '800px';\n    container.style.height = '600px';\n    container.style.margin = '20px auto';\n    document.body.appendChild(container);\n    // Listen for initialization events from the Electron main process\n    window.electron.onGameInit((config) => {\n        console.log('Received game init from Electron with config:', config);\n        // Apply configuration\n        if (config.debug !== undefined)\n            game.debug = config.debug;\n        if (config.targetFPS !== undefined)\n            game.targetFPS = config.targetFPS;\n        if (config.useFixedTimestep !== undefined)\n            game.useFixedTimestep = config.useFixedTimestep;\n        if (config.fixedTimestepValue !== undefined)\n            game.fixedTimestepValue = config.fixedTimestepValue;\n        if (config.timeScale !== undefined)\n            game.timeScale = config.timeScale;\n        // Initialize the game example\n        initGame();\n    });\n    // If no init event received after a timeout, auto-initialize (for browser testing)\n    setTimeout(() => {\n        if (game.state === 'uninitialized') {\n            console.log('No init from Electron received, auto-initializing game');\n            initGame();\n        }\n    }, 1000);\n});\n/**\n * Initialize the game\n */\nfunction initGame() {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            // Register event listeners\n            game.eventEmitter.subscribe(GameEventType.UPDATE, onGameUpdate);\n            game.eventEmitter.subscribe(GameEventType.ERROR, onGameError);\n            // Initialize the game example\n            yield gameExample.init();\n            // Notify Electron that the game has initialized\n            window.electron.sendGameState(game.state);\n            console.log('Game initialized successfully');\n        }\n        catch (error) {\n            console.error('Failed to initialize game:', error);\n            window.electron.sendGameError(error instanceof Error ? error.message : String(error));\n        }\n    });\n}\n/**\n * Handle game updates\n */\nfunction onGameUpdate(game, deltaTime) {\n    // Send game stats to Electron every second\n    if (game.stats.totalFrames % 60 === 0) {\n        // Add deltaTime to the stats\n        const statsWithDelta = Object.assign(Object.assign({}, game.stats), { deltaTime });\n        window.electron.sendGameStats(statsWithDelta);\n    }\n}\n/**\n * Handle game errors\n */\nfunction onGameError(game, error) {\n    console.error('Game error:', error);\n    window.electron.sendGameError(error.message);\n}\n// Electron interface types are defined in src/app/types/electron.d.ts\n// Export coordinate system components\nimport { CoordinateSystem } from './core/utils/CoordinateSystem';\nimport { CoordinateSystemVerification } from './core/utils/CoordinateSystemVerification';\nimport { HexPositionComponent } from './components/HexPosition';\nimport { HexPathfinding } from './core/pathfinding/HexPathfinding';\n// Export the game for direct access\nexport { game, gameExample, \n// Coordinate system exports\nCoordinateSystem, CoordinateSystemVerification, HexPositionComponent, HexPathfinding };\n// Add to window.TeraFlux if it exists (for testing)\nif (typeof window !== 'undefined') {\n    // Create TeraFlux namespace if doesn't exist\n    if (!window.TeraFlux) {\n        window.TeraFlux = { Game: {} };\n    }\n    else if (!window.TeraFlux.Game) {\n        window.TeraFlux.Game = {};\n    }\n    // Add coordinate system components to TeraFlux namespace\n    if (window.TeraFlux && window.TeraFlux.Game) {\n        window.TeraFlux.Game.CoordinateSystem = CoordinateSystem;\n        window.TeraFlux.Game.CoordinateSystemVerification = CoordinateSystemVerification;\n        window.TeraFlux.Game.HexPositionComponent = HexPositionComponent;\n        window.TeraFlux.Game.HexPathfinding = HexPathfinding;\n    }\n}\n"],"names":[],"sourceRoot":""}